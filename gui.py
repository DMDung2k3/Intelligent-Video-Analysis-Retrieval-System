"""
Enhanced Retrieval System - Complete GUI System (Refactored)
===============================================

Modern PyQt5-based desktop application with advanced features:
- Enhanced main window with search interface
- Advanced result display with split view
- OpenAI chat interface for conversational search
- Export dialog with multiple formats
- Progress tracking and performance monitoring
- Frame filter functionality
- Real-time updates and responsive design

Author: Enhanced Retrieval System
Version: 2.1 (Refactored)
"""

import os
import sys
import json
import time
import threading
import inspect
import csv
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple, Callable
from functools import partial
from dataclasses import dataclass
import traceback

# PyQt5 imports
try:
    from PyQt5.QtCore import (
        Qt, QThread, QTimer, QObject, pyqtSignal, pyqtSlot, QEvent,
        QPropertyAnimation, QEasingCurve, QRect, QSize, QPoint,
        QByteArray, QBuffer, QIODevice, QMimeData, QUrl
    )
    from PyQt5.QtWidgets import (
        QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
        QLabel, QTextEdit, QPushButton, QScrollArea, QFileDialog,
        QMessageBox, QDialog, QLineEdit, QComboBox, QCheckBox, QRadioButton,
        QProgressBar, QProgressDialog, QStatusBar, QMenuBar, QMenu, QAction,
        QSplitter, QTabWidget, QGroupBox, QSpinBox, QSlider,
        QTableWidget, QTableWidgetItem, QHeaderView, QFrame,
        QGridLayout, QFormLayout, QSizePolicy, QSpacerItem, QInputDialog
    )
    from PyQt5.QtGui import (
        QPixmap, QImage, QFont, QIcon, QPainter, QPen, QBrush, QColor,
        QLinearGradient, QRadialGradient, QPalette, QCursor, QTextCursor,
        QDragEnterEvent, QDropEvent
    )
    HAS_PYQT5 = True
except ImportError:
    HAS_PYQT5 = False

from utils import Config, Logger, PerformanceMonitor, FileManager
from core import SearchResult, KeyframeMetadata
from system import EnhancedRetrievalSystem, SearchOptions, SystemStatus

# Placeholder for base64 image - you can replace this
image_base64 = "data:image/png;base64,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"

# ================================================================================
# THEME AND STYLING
# ================================================================================

@dataclass
class UITheme:
    """UI theme configuration"""
    primary_color: str = "#d67302"
    secondary_color: str = "#FFC107" 
    background_color: str = "#FAFAFA"
    text_color: str = "#212121"
    border_color: str = "#E0E0E0"
    success_color: str = "#4CAF50"
    warning_color: str = "#FF9800"
    error_color: str = "#F44336"
    
    def get_stylesheet(self) -> str:
        """Get complete stylesheet for application"""
        return f"""
        QMainWindow {{
            background-color: {self.background_color};
            color: {self.text_color};
        }}
        
        QPushButton {{
            background-color: {self.primary_color};
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: bold;
        }}
        
        QPushButton:hover {{
            background-color: #b05c02;
        }}
        
        QPushButton:pressed {{
            background-color: #8a4702;
        }}
        
        QPushButton:disabled {{
            background-color: #BDBDBD;
            color: #757575;
        }}
        
        QLineEdit, QTextEdit {{
            border: 2px solid {self.border_color};
            border-radius: 4px;
            padding: 8px;
            background-color: white;
        }}
        
        QLineEdit:focus, QTextEdit:focus {{
            border-color: {self.primary_color};
        }}
        
        QLabel {{
            color: {self.text_color};
        }}
        
        QGroupBox {{
            font-weight: bold;
            border: 2px solid {self.border_color};
            border-radius: 8px;
            margin: 10px 0px;
            padding-top: 10px;
        }}
        
        QGroupBox::title {{
            subcontrol-origin: margin;
            left: 10px;
            padding: 0 5px 0 5px;
        }}
        
        QScrollArea {{
            border: 1px solid {self.border_color};
            border-radius: 4px;
        }}
        
        QProgressBar {{
            border: 2px solid {self.border_color};
            border-radius: 5px;
            text-align: center;
        }}
        
        QProgressBar::chunk {{
            background-color: {self.primary_color};
            border-radius: 3px;
        }}
        
        QStatusBar {{
            background-color: {self.background_color};
            border-top: 1px solid {self.border_color};
        }}
        
        QMenuBar {{
            background-color: {self.background_color};
            border-bottom: 1px solid {self.border_color};
        }}
        
        QMenu {{
            background-color: white;
            border: 1px solid {self.border_color};
        }}
        
        QTabWidget::pane {{
            border: 1px solid {self.border_color};
        }}
        
        QTabBar::tab {{
            background-color: {self.background_color};
            padding: 8px 16px;
            margin-right: 2px;
        }}
        
        QTabBar::tab:selected {{
            background-color: {self.primary_color};
            color: white;
        }}
        
        QTableWidget {{
            gridline-color: {self.border_color};
            background-color: white;
            alternate-background-color: #F5F5F5;
        }}
        
        QTableWidget::item:selected {{
            background-color: {self.primary_color};
            color: white;
        }}
        
        QScrollBar:vertical {{
            background-color: {self.background_color};
            width: 12px;
            border-radius: 6px;
        }}
        
        QScrollBar::handle:vertical {{
            background-color: {self.border_color};
            border-radius: 6px;
        }}
        
        QScrollBar::handle:vertical:hover {{
            background-color: {self.primary_color};
        }}
        """

# ================================================================================
# WORKER THREAD AND PROGRESS MANAGEMENT
# ================================================================================

class WorkerThread(QThread):
    """Background Worker Thread - Handles long-running operations without blocking the UI"""
    
    # Signals
    progress_updated = pyqtSignal(int, int, str)  # current, total, message
    result_ready = pyqtSignal(object)  # result data
    error_occurred = pyqtSignal(str)  # error message
    finished = pyqtSignal()
    
    def __init__(self, target_function: Callable, *args, **kwargs):
        """Initialize worker thread"""
        super().__init__()
        self.target_function = target_function
        self.args = args
        self.kwargs = kwargs
        self._is_cancelled = False
    
    def run(self):
        """Execute the target function"""
        try:
            if self.isInterruptionRequested() or self._is_cancelled:
                return
            
            if self._function_supports_progress_callback():
                self.kwargs['progress_callback'] = self._progress_callback
            
            result = self.target_function(*self.args, **self.kwargs)
            
            if not self._is_cancelled and not self.isInterruptionRequested():
                self.result_ready.emit(result)
                
        except Exception as e:
            if not self._is_cancelled and not self.isInterruptionRequested():
                self.error_occurred.emit(str(e))
        finally:
            self.finished.emit()
    
    def _function_supports_progress_callback(self) -> bool:
        """Check if target function supports progress_callback parameter"""
        try:
            sig = inspect.signature(self.target_function)
            return 'progress_callback' in sig.parameters
        except Exception:
            return False
    
    def cancel(self):
        """Cancel the operation"""
        self._is_cancelled = True
        self.requestInterruption()
        if self.isRunning():
            self.quit()
    
    def _progress_callback(self, current: int, total: int, message: str):
        """Progress callback for target function"""
        if not self._is_cancelled:
            self.progress_updated.emit(current, total, message)


class ProgressManager(QWidget):
    """Centralized Progress Tracking - Manages and displays progress for long-running operations"""
    
    def __init__(self, parent=None):
        """Initialize progress manager"""
        super().__init__(parent)
        self.active_operations = {}
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup progress UI"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        self.progress_widget = QWidget()
        self.progress_layout = QVBoxLayout(self.progress_widget)
        
        layout.addWidget(self.progress_widget)
        self.progress_widget.hide()
    
    def show_progress(self, operation_id: str, title: str, total: int = 100) -> QProgressBar:
        """Show progress for an operation"""
        progress_bar = QProgressBar()
        progress_bar.setRange(0, total)
        progress_bar.setValue(0)
        progress_bar.setFormat(f"{title} - %p%")
        
        self.progress_layout.addWidget(QLabel(title))
        self.progress_layout.addWidget(progress_bar)
        
        self.active_operations[operation_id] = {
            "progress_bar": progress_bar,
            "title": title,
            "start_time": time.time(),
            "total": total
        }
        
        self.progress_widget.show()
        return progress_bar
    
    def update_progress(self, operation_id: str, current: int, message: str = ""):
        """Update progress for an operation with ETA calculation"""
        if operation_id in self.active_operations:
            operation = self.active_operations[operation_id]
            progress_bar = operation["progress_bar"]
            title = operation["title"]
            start_time = operation["start_time"]
            total = operation["total"]
            
            progress_bar.setValue(current)
            
            eta_text = ""
            if current > 0 and current < total:
                elapsed_time = time.time() - start_time
                if elapsed_time > 0:
                    rate = current / elapsed_time
                    remaining_items = total - current
                    eta_seconds = remaining_items / rate
                    
                    if eta_seconds < 60:
                        eta_text = f" - ETA: {int(eta_seconds)}s"
                    elif eta_seconds < 3600:
                        minutes = int(eta_seconds // 60)
                        seconds = int(eta_seconds % 60)
                        eta_text = f" - ETA: {minutes}m {seconds}s"
                    else:
                        hours = int(eta_seconds // 3600)
                        minutes = int((eta_seconds % 3600) // 60)
                        eta_text = f" - ETA: {hours}h {minutes}m"
            
            if message:
                progress_bar.setFormat(f"{title} - {message}{eta_text} - %p%")
            else:
                progress_bar.setFormat(f"{title}{eta_text} - %p%")
    
    def finish_progress(self, operation_id: str):
        """Finish progress for an operation"""
        if operation_id in self.active_operations:
            operation = self.active_operations.pop(operation_id)
            progress_bar = operation["progress_bar"]
            
            progress_bar.deleteLater()
            if self.progress_layout.count() > 0:
                item = self.progress_layout.itemAt(self.progress_layout.count() - 2)
                if item and item.widget():
                    item.widget().deleteLater()
            
            if not self.active_operations:
                self.progress_widget.hide()

# ================================================================================
# THUMBNAIL AND IMAGE WIDGETS
# ================================================================================

class ClickableThumbnail(QLabel):
    """Clickable Thumbnail Widget - A QLabel that emits signals when clicked"""
    
    clicked = pyqtSignal(int)  # row index
    
    def __init__(self, row_index: int, parent=None):
        """Initialize clickable thumbnail"""
        super().__init__(parent)
        
        self.row_index = row_index
        self.setAlignment(Qt.AlignCenter)
        self.setStyleSheet("border: 1px solid #ccc; background-color: white;")
        self.setCursor(Qt.PointingHandCursor)
        self.setMouseTracking(True)
    
    def mousePressEvent(self, event):
        """Handle mouse press event"""
        if event.button() == Qt.LeftButton:
            self.clicked.emit(self.row_index)
        super().mousePressEvent(event)
    
    def enterEvent(self, event):
        """Handle mouse enter event - add hover effect"""
        self.setStyleSheet("border: 2px solid #d67302; background-color: #FFF3E0;")
        super().enterEvent(event)
    
    def leaveEvent(self, event):
        """Handle mouse leave event - remove hover effect"""
        self.setStyleSheet("border: 1px solid #ccc; background-color: white;")
        super().leaveEvent(event)


class ZoomableImageWidget(QWidget):
    """Zoomable Image Display Widget - Displays images with zoom capabilities"""
    
    def __init__(self, parent=None):
        """Initialize zoomable image widget"""
        super().__init__(parent)
        
        self.scale_factor = 1.0
        self.min_scale = 0.1
        self.max_scale = 5.0
        self.scale_step = 0.1
        
        self.original_pixmap = None
        self.scaled_pixmap = None
        
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup the zoomable image UI"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Control buttons
        controls_layout = QHBoxLayout()
        
        self.zoom_in_btn = QPushButton("+")
        self.zoom_in_btn.setMaximumSize(40, 30)
        self.zoom_in_btn.setToolTip("Zoom In")
        self.zoom_in_btn.clicked.connect(self.zoom_in)
        
        self.zoom_out_btn = QPushButton("-")
        self.zoom_out_btn.setMaximumSize(40, 30)
        self.zoom_out_btn.setToolTip("Zoom Out")
        self.zoom_out_btn.clicked.connect(self.zoom_out)
        
        self.fit_btn = QPushButton("")
        self.fit_btn.setMaximumSize(40, 30)
        self.fit_btn.setToolTip("Fit to Window")
        self.fit_btn.clicked.connect(self.fit_to_window)
        
        self.actual_size_btn = QPushButton("1:1")
        self.actual_size_btn.setMaximumSize(60, 30)
        self.actual_size_btn.setToolTip("Actual Size")
        self.actual_size_btn.clicked.connect(self.actual_size)
        
        self.zoom_label = QLabel("100%")
        self.zoom_label.setMinimumWidth(50)
        self.zoom_label.setAlignment(Qt.AlignCenter)
        
        controls_layout.addWidget(self.zoom_in_btn)
        controls_layout.addWidget(self.zoom_out_btn)
        controls_layout.addWidget(self.fit_btn)
        controls_layout.addWidget(self.actual_size_btn)
        controls_layout.addWidget(self.zoom_label)
        controls_layout.addStretch()
        
        # Scrollable image area
        self.scroll_area = QScrollArea()
        self.scroll_area.setAlignment(Qt.AlignCenter)
        self.scroll_area.setStyleSheet("QScrollArea { border: 1px solid #ccc; background-color: #f0f0f0; }")
        
        self.image_label = QLabel()
        self.image_label.setAlignment(Qt.AlignCenter)
        self.image_label.setStyleSheet("background-color: white;")
        self.image_label.setText("No image loaded")
        
        self.scroll_area.setWidget(self.image_label)
        self.scroll_area.setWidgetResizable(True)
        
        # Enable mouse wheel events
        self.scroll_area.wheelEvent = self._wheel_event
        
        layout.addLayout(controls_layout)
        layout.addWidget(self.scroll_area)
    
    def set_image(self, pixmap: QPixmap):
        """Set image to display"""
        if pixmap and not pixmap.isNull():
            self.original_pixmap = pixmap
            self.scale_factor = 1.0
            self._update_image()
            self.fit_to_window()
        else:
            self.clear_image()
    
    def clear_image(self):
        """Clear the displayed image"""
        self.original_pixmap = None
        self.scaled_pixmap = None
        self.scale_factor = 1.0
        self.image_label.clear()
        self.image_label.setText("No image loaded")
        self._update_zoom_label()
    
    def zoom_in(self):
        """Zoom in the image"""
        if self.original_pixmap:
            new_scale = min(self.scale_factor + self.scale_step, self.max_scale)
            if new_scale != self.scale_factor:
                self.scale_factor = new_scale
                self._update_image()
    
    def zoom_out(self):
        """Zoom out the image"""
        if self.original_pixmap:
            new_scale = max(self.scale_factor - self.scale_step, self.min_scale)
            if new_scale != self.scale_factor:
                self.scale_factor = new_scale
                self._update_image()
    
    def fit_to_window(self):
        """Fit image to window size"""
        if not self.original_pixmap:
            return
        
        available_size = self.scroll_area.size()
        available_size.setWidth(available_size.width() - 20)
        available_size.setHeight(available_size.height() - 20)
        
        image_size = self.original_pixmap.size()
        scale_x = available_size.width() / image_size.width()
        scale_y = available_size.height() / image_size.height()
        
        self.scale_factor = min(scale_x, scale_y, 1.0)
        self.scale_factor = max(self.scale_factor, self.min_scale)
        
        self._update_image()
    
    def actual_size(self):
        """Show image at actual size (100%)"""
        if self.original_pixmap:
            self.scale_factor = 1.0
            self._update_image()
    
    def _update_image(self):
        """Update the displayed image with current scale"""
        if not self.original_pixmap:
            return
        
        new_size = self.original_pixmap.size() * self.scale_factor
        
        self.scaled_pixmap = self.original_pixmap.scaled(
            new_size,
            Qt.KeepAspectRatio,
            Qt.SmoothTransformation
        )
        
        self.image_label.setPixmap(self.scaled_pixmap)
        self.image_label.resize(self.scaled_pixmap.size())
        
        self._update_zoom_label()
    
    def _update_zoom_label(self):
        """Update the zoom percentage label"""
        percentage = int(self.scale_factor * 100)
        self.zoom_label.setText(f"{percentage}%")
    
    def _wheel_event(self, event):
        """Handle mouse wheel events for zooming"""
        if not self.original_pixmap:
            return
        
        delta = event.angleDelta().y()
        
        if delta > 0:
            self.zoom_in()
        else:
            self.zoom_out()
        
        event.accept()


class InteractiveThumbnail(QLabel):
    """Enhanced Interactive Thumbnail - Advanced thumbnail widget with hover effects"""
    
    clicked = pyqtSignal(object)  # metadata
    double_clicked = pyqtSignal(object)  # metadata
    context_menu_requested = pyqtSignal(object, QPoint)  # metadata, position
    
    def __init__(self, metadata: KeyframeMetadata, thumbnail_size: int = 350, parent=None):
        """Initialize interactive thumbnail"""
        super().__init__(parent)
        
        self.metadata = metadata
        self.thumbnail_size = thumbnail_size
        self.is_selected = False
        self.hover_animation = None
        
        self._setup_thumbnail()
        self._setup_interactions()
        
        self.setFixedSize(thumbnail_size, int(thumbnail_size * 0.75))
        self.setAlignment(Qt.AlignCenter)
        self.setStyleSheet("""
            QLabel {
                border: 2px solid #E0E0E0;
                border-radius: 8px;
                background-color: white;
            }
            QLabel:hover {
                border-color: #d67302;
                background-color: #FFF3E0;
            }
        """)
    
    def _setup_thumbnail(self):
        """Setup thumbnail image"""
        try:
            if os.path.exists(self.metadata.file_path):
                pixmap = QPixmap(self.metadata.file_path)
                if not pixmap.isNull():
                    scaled_pixmap = pixmap.scaledToWidth(
                        self.thumbnail_size - 10,
                        Qt.SmoothTransformation
                    )
                    self.setPixmap(scaled_pixmap)
                else:
                    self._set_placeholder_image("Invalid Image")
            else:
                self._set_placeholder_image("Image Not Found")
                
        except Exception as e:
            self._set_placeholder_image(f"Error: {str(e)}")
    
    def _set_placeholder_image(self, text: str):
        """Set placeholder image with text"""
        placeholder = QPixmap(self.thumbnail_size - 10, int(self.thumbnail_size * 0.75) - 10)
        placeholder.fill(QColor("#F5F5F5"))
        
        painter = QPainter(placeholder)
        painter.setPen(QPen(QColor("#757575")))
        painter.drawText(placeholder.rect(), Qt.AlignCenter, text)
        painter.end()
        
        self.setPixmap(placeholder)
    
    def _setup_interactions(self):
        """Setup mouse interactions"""
        self.setMouseTracking(True)
        self.setCursor(QCursor(Qt.PointingHandCursor))
    
    def mousePressEvent(self, event):
        """Handle mouse press events"""
        if event.button() == Qt.LeftButton:
            self.clicked.emit(self.metadata)
        elif event.button() == Qt.RightButton:
            self.context_menu_requested.emit(self.metadata, event.globalPos())
        super().mousePressEvent(event)
    
    def mouseDoubleClickEvent(self, event):
        """Handle double click events"""
        if event.button() == Qt.LeftButton:
            self.double_clicked.emit(self.metadata)
            self._show_image_dialog(self.metadata)
        super().mouseDoubleClickEvent(event)
    
    def enterEvent(self, event):
        """Handle mouse enter (hover start)"""
        self._animate_hover(True)
        super().enterEvent(event)
    
    def leaveEvent(self, event):
        """Handle mouse leave (hover end)"""
        self._animate_hover(False)
        super().leaveEvent(event)
    
    def _animate_hover(self, hover_in: bool):
        """Animate hover effect"""
        if hasattr(self, 'hover_animation') and self.hover_animation:
            self.hover_animation.stop()
        
        self.hover_animation = QPropertyAnimation(self, b"geometry")
        self.hover_animation.setDuration(200)
        self.hover_animation.setEasingCurve(QEasingCurve.OutCubic)
        
        start_rect = self.geometry()
        if hover_in:
            end_rect = QRect(
                start_rect.x() - 2,
                start_rect.y() - 2,
                start_rect.width() + 4,
                start_rect.height() + 4
            )
        else:
            end_rect = start_rect
        
        self.hover_animation.setStartValue(start_rect)
        self.hover_animation.setEndValue(end_rect)
        self.hover_animation.start()
    
    def set_selected(self, selected: bool):
        """Set selection state"""
        self.is_selected = selected
        if selected:
            self.setStyleSheet("""
                QLabel {
                    border: 3px solid #d67302;
                    border-radius: 8px;
                    background-color: #FFF3E0;
                }
            """)
        else:
            self.setStyleSheet("""
                QLabel {
                    border: 2px solid #E0E0E0;
                    border-radius: 8px;
                    background-color: white;
                }
                QLabel:hover {
                    border-color: #d67302;
                    background-color: #FFF3E0;
                }
            """)
    
    def _show_image_dialog(self, metadata: KeyframeMetadata):
        """Show full size image dialog"""
        dialog = QDialog(self)
        dialog.setWindowTitle(f"{metadata.folder_name} - {metadata.image_name}")
        dialog.setModal(True)
        
        layout = QVBoxLayout(dialog)
        
        image_label = QLabel()
        if os.path.exists(metadata.file_path):
            pixmap = QPixmap(metadata.file_path)
            if not pixmap.isNull():
                screen_size = QApplication.desktop().screenGeometry()
                max_size = min(screen_size.width() * 0.8, screen_size.height() * 0.8)
                scaled_pixmap = pixmap.scaled(
                    int(max_size), int(max_size),
                    Qt.KeepAspectRatio, Qt.SmoothTransformation
                )
                image_label.setPixmap(scaled_pixmap)
            else:
                image_label.setText("Failed to load image")
        else:
            image_label.setText("Image file not found")
        
        image_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(image_label)
        
        info_text = f"Folder: {metadata.folder_name}\n"
        info_text += f"Image: {metadata.image_name}\n"
        info_text += f"Frame ID: {metadata.frame_id}\n"
        info_text += f"Path: {metadata.file_path}"
        
        info_label = QLabel(info_text)
        info_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(info_label)
        
        dialog.resize(800, 600)
        dialog.exec_()

# ================================================================================
# RESULT DISPLAY WIDGET
# ================================================================================

class ResultDisplayWidget(QWidget):
    """Advanced Result Display Widget - Displays search results in a split view"""
    
    selection_changed = pyqtSignal(list)  # selected metadata
    
    def __init__(self, parent=None, system=None):
        super().__init__(parent)
        self.selected_items = []
        self.results = []
        self.system = system
        self.logger = system.logger if system else None
        
        # PATCH: Store system reference globally for recovery
        if system:
            app = QApplication.instance()
            if app:
                app.retrieval_system = system
        
        self._setup_ui()
    
    def _recover_system_reference(self) -> bool:
        """Multi-strategy system reference recovery"""
        if hasattr(self, 'system') and self.system:
            return True
            
        # Strategy 1: From QApplication
        app = QApplication.instance()
        if app and hasattr(app, 'retrieval_system') and app.retrieval_system:
            self.system = app.retrieval_system
            return True
        
        # Strategy 2: From parent widgets
        parent = self.parent()
        while parent:
            if hasattr(parent, 'system') and parent.system:
                self.system = parent.system
                return True
            parent = parent.parent()
        
        # Strategy 3: Try to create minimal system for .rvdb access
        try:
            from system import EnhancedRetrievalSystem
            from utils import Logger
            self.system = EnhancedRetrievalSystem()
            # Don't call full initialize, just set up basic components
            self.system.logger = Logger()
            return True
        except Exception as e:
            pass
            
        return False
    
    def _setup_ui(self):
        """Setup the split view UI"""
        self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
        
        main_layout = QHBoxLayout(self)
        main_layout.setContentsMargins(5, 5, 5, 5)
        
        splitter = QSplitter(Qt.Horizontal)
        splitter.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        
        # Left panel - Results list
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        
        self.results_list = QTableWidget()
        self.results_list.setColumnCount(2)
        self.results_list.setHorizontalHeaderLabels(["", "Frame"])
        self.results_list.horizontalHeader().setSectionResizeMode(0, QHeaderView.Fixed)
        self.results_list.horizontalHeader().setSectionResizeMode(1, QHeaderView.Stretch)
        self.results_list.setSelectionBehavior(QTableWidget.SelectRows)
        self.results_list.setSelectionMode(QTableWidget.SingleSelection)
        self.results_list.itemSelectionChanged.connect(self._on_result_selected)
        self.results_list.itemChanged.connect(self._on_checkbox_changed)
        self.results_list.setColumnWidth(0, 30)
        
        self.results_list.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.results_list.horizontalHeader().setStretchLastSection(True)
        
        left_layout.addWidget(self.results_list)
        
        # Selection controls
        controls_layout = QHBoxLayout()

        self.select_all_btn = QPushButton("Select All")
        self.select_all_btn.clicked.connect(self._select_all)
        controls_layout.addWidget(self.select_all_btn)

        self.clear_selection_btn = QPushButton("Clear Selection")
        self.clear_selection_btn.clicked.connect(self._clear_selection)
        controls_layout.addWidget(self.clear_selection_btn)

        self.add_csv_btn = QPushButton("Add to CSV")
        self.add_csv_btn.clicked.connect(self._add_to_csv)
        controls_layout.addWidget(self.add_csv_btn)

        left_layout.addLayout(controls_layout)
        
        # Right panel - Preview and CSV List
        right_panel = QWidget()
        right_panel.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        right_layout = QVBoxLayout(right_panel)
        
        # Zoomable preview widget
        self.preview_widget = ZoomableImageWidget()
        self.preview_widget.setMinimumSize(400, 300)
        self.preview_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        
        # Bottom area with tabs
        bottom_tabs = QTabWidget()
        
        # Metadata tab
        metadata_tab = QWidget()
        metadata_layout = QVBoxLayout(metadata_tab)
        
        self.metadata_text = QTextEdit()
        self.metadata_text.setReadOnly(True)
        self.metadata_text.setMaximumHeight(150)
        metadata_layout.addWidget(self.metadata_text)
        
        # CSV Results tab
        csv_tab = QWidget()
        csv_layout = QVBoxLayout(csv_tab)
        
        self.csv_results_list = QTableWidget()
        self.csv_results_list.setColumnCount(3)
        self.csv_results_list.setHorizontalHeaderLabels(["", "Frame", "Status"])
        self.csv_results_list.horizontalHeader().setSectionResizeMode(0, QHeaderView.Fixed)
        self.csv_results_list.horizontalHeader().setSectionResizeMode(1, QHeaderView.Stretch)
        self.csv_results_list.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeToContents)
        self.csv_results_list.setColumnWidth(0, 30)
        self.csv_results_list.itemChanged.connect(self._on_csv_checkbox_changed)
        
        csv_layout.addWidget(self.csv_results_list)
        
        # Q&A input section
        qa_layout = QHBoxLayout()
        
        self.qa_checkbox = QCheckBox("Q&A")
        self.qa_checkbox.setToolTip("Check to add Q&A data to CSV export")
        qa_layout.addWidget(self.qa_checkbox)
        
        self.qa_textbox = QLineEdit()
        self.qa_textbox.setPlaceholderText("Enter Q&A data (only added when checkbox is checked)")
        self.qa_textbox.setEnabled(False)
        qa_layout.addWidget(self.qa_textbox)
        
        self.qa_checkbox.stateChanged.connect(self._on_qa_checkbox_changed)
        
        csv_layout.addLayout(qa_layout)
        
        # CSV controls - Fixed: Made buttons wider
        csv_controls_layout = QHBoxLayout()
        
        self.remove_from_csv_btn = QPushButton("Remove Selected")
        self.remove_from_csv_btn.setMinimumWidth(120)  # Fixed: Wider button
        self.remove_from_csv_btn.clicked.connect(self._remove_from_csv)
        csv_controls_layout.addWidget(self.remove_from_csv_btn)
        
        self.clear_csv_btn = QPushButton("Clear All")
        self.clear_csv_btn.setMinimumWidth(100)  # Fixed: Wider button
        self.clear_csv_btn.clicked.connect(self._clear_csv_list)
        csv_controls_layout.addWidget(self.clear_csv_btn)
        
        self.export_csv_btn = QPushButton("Export to CSV")
        self.export_csv_btn.setMinimumWidth(120)  # Fixed: Wider button
        self.export_csv_btn.clicked.connect(self._export_csv_list)
        csv_controls_layout.addWidget(self.export_csv_btn)
        
        csv_controls_layout.addStretch()
        csv_layout.addLayout(csv_controls_layout)
        
        # Add tabs
        bottom_tabs.addTab(metadata_tab, " Image Info")
        bottom_tabs.addTab(csv_tab, f" CSV List (0)")
        
        self.csv_tab_widget = bottom_tabs
        
        right_layout.addWidget(self.preview_widget, 1)
        right_layout.addWidget(bottom_tabs)
        
        # Initialize CSV results tracking
        self.csv_results = []
        
        splitter.addWidget(left_panel)
        splitter.addWidget(right_panel)
        
        splitter.setSizes([400, 600])
        splitter.setStretchFactor(0, 2)
        splitter.setStretchFactor(1, 3)
        
        left_panel.setMinimumWidth(200)
        right_panel.setMinimumWidth(400)
        
        main_layout.addWidget(splitter)
    
    def display_results(self, results):
        """Display search results in the split view"""
        self.results = results
        self.results_list.setRowCount(0)
        
        self.results_list.setRowHeight(0, 80)
        
        for i, result in enumerate(results):
            self.results_list.insertRow(i)
            self.results_list.setRowHeight(i, 80)
            
            # Checkbox
            checkbox_item = QTableWidgetItem()
            checkbox_item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
            checkbox_item.setCheckState(Qt.Unchecked)
            self.results_list.setItem(i, 0, checkbox_item)
            
            # Full Image (displayed as thumbnail-sized)
            try:
                pixmap = self._get_full_image_pixmap(result.metadata, search_result=result)
                if pixmap and not pixmap.isNull():
                    thumbnail = pixmap.scaled(70, 70, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                    
                    thumbnail_label = ClickableThumbnail(i)
                    thumbnail_label.setPixmap(thumbnail)
                    thumbnail_label.clicked.connect(self._on_thumbnail_clicked)
                    
                    self.results_list.setCellWidget(i, 1, thumbnail_label)
                else:
                    # Fallback: create placeholder thumbnail directly  
                    placeholder = self._create_placeholder_thumbnail(result.metadata, size=(70, 70))
                    thumbnail_label = ClickableThumbnail(i)
                    thumbnail_label.setPixmap(placeholder)
                    thumbnail_label.clicked.connect(self._on_thumbnail_clicked)
                    self.results_list.setCellWidget(i, 1, thumbnail_label)
            except Exception as e:
                # Exception fallback: create placeholder thumbnail
                placeholder = self._create_placeholder_thumbnail(result.metadata, size=(70, 70))
                thumbnail_label = ClickableThumbnail(i)
                thumbnail_label.setPixmap(placeholder)
                thumbnail_label.clicked.connect(self._on_thumbnail_clicked)
                self.results_list.setCellWidget(i, 1, thumbnail_label)
            
            checkbox_item.setData(Qt.UserRole, {'metadata': result.metadata, 'search_result': result})
        
        self.preview_widget.clear_image()
        self.metadata_text.clear()
        self._update_button_states()
    
    def _on_result_selected(self):
        """Handle result selection in the list"""
        selected_rows = self.results_list.selectedItems()
        if not selected_rows:
            return
            
        row = selected_rows[0].row()
        user_data = self.results_list.item(row, 0).data(Qt.UserRole)
        metadata = user_data['metadata'] if isinstance(user_data, dict) else user_data
        search_result = user_data.get('search_result') if isinstance(user_data, dict) else None
        
        try:
            pixmap = self._get_full_image_pixmap(metadata, search_result=search_result)
            if pixmap and not pixmap.isNull():
                self.preview_widget.set_image(pixmap)
                
                metadata_str = (
                    f"File: {metadata.file_path}\n"
                    f"Folder: {metadata.folder_name}\n"
                    f"Image: {metadata.image_name}\n"
                    f"Frame ID: {metadata.frame_id}"
                )
                self.metadata_text.setText(metadata_str)
            else:
                self.preview_widget.clear_image()
                self.metadata_text.clear()
        except Exception as e:
            self.preview_widget.clear_image()
            self.metadata_text.clear()
    
    def _on_thumbnail_clicked(self, row_index: int):
        """Handle thumbnail click - show large image in preview"""
        try:
            user_data = self.results_list.item(row_index, 0).data(Qt.UserRole)
            if not user_data:
                return
            
            metadata = user_data['metadata'] if isinstance(user_data, dict) else user_data
            search_result = user_data.get('search_result') if isinstance(user_data, dict) else None
            
            pixmap = self._get_full_image_pixmap(metadata, search_result=search_result)
            if pixmap and not pixmap.isNull():
                self.preview_widget.set_image(pixmap)
                
                metadata_str = (
                    f"File: {metadata.file_path}\n"
                    f"Folder: {metadata.folder_name}\n"
                    f"Image: {metadata.image_name}\n"
                    f"Frame ID: {metadata.frame_id}"
                )
                self.metadata_text.setText(metadata_str)
                
                self.results_list.selectRow(row_index)
            else:
                self.preview_widget.clear_image()
                self.metadata_text.clear()
        except Exception as e:
            self.preview_widget.clear_image()
            self.metadata_text.clear()
    
    def _on_checkbox_changed(self, item):
        """Handle checkbox state changes"""
        if item.column() != 0:
            return
            
        user_data = item.data(Qt.UserRole)
        metadata = user_data['metadata'] if isinstance(user_data, dict) else user_data
        if item.checkState() == Qt.Checked:
            if metadata not in self.selected_items:
                self.selected_items.append(metadata)
        else:
            if metadata in self.selected_items:
                self.selected_items.remove(metadata)
        
        self.selection_changed.emit(self.selected_items)
        self._update_button_states()
    
    def _select_all(self):
        """Select all items in the list"""
        for row in range(self.results_list.rowCount()):
            item = self.results_list.item(row, 0)
            item.setCheckState(Qt.Checked)

    def _clear_selection(self):
        """Clear all selections"""
        for row in range(self.results_list.rowCount()):
            item = self.results_list.item(row, 0)
            item.setCheckState(Qt.Unchecked)

    def _add_to_csv(self):
        """Add selected items to CSV list"""
        selected_results = [
            result for result in self.results
            if result.metadata in self.selected_items
        ]
        
        if not selected_results:
            QMessageBox.warning(self, "Warning", "No items selected")
            return
        
        added_count = 0
        for result in selected_results:
            if len(self.csv_results) >= 100:
                QMessageBox.warning(
                    self, 
                    "Limit Reached", 
                    f"CSV list has reached the maximum limit of 100 items.\nCannot add more items."
                )
                break
            
            already_exists = any(
                csv_result.metadata.file_path == result.metadata.file_path 
                for csv_result in self.csv_results
            )
            
            if not already_exists:
                self.csv_results.append(result)
                self._add_csv_list_item(result)
                added_count += 1
        
        self._update_csv_tab_title()
        
        if added_count > 0:
            QMessageBox.information(
                self, 
                "Success", 
                f"Added {added_count} items to CSV list.\nDuplicates were skipped."
            )
        else:
            QMessageBox.information(
                self, 
                "Info", 
                "All selected items were already in the CSV list."
            )
        
        self._clear_selection()
    
    def _update_button_states(self):
        """Update button states based on selection"""
        has_selection = bool(self.selected_items)
        has_results = bool(self.results)
        
        self.add_csv_btn.setEnabled(has_selection)
        self.clear_selection_btn.setEnabled(has_selection)
        self.select_all_btn.setEnabled(has_results)
    
    def _add_csv_list_item(self, result):
        """Add an item to the CSV results list"""
        row = self.csv_results_list.rowCount()
        self.csv_results_list.insertRow(row)
        
        checkbox_item = QTableWidgetItem()
        checkbox_item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
        checkbox_item.setCheckState(Qt.Checked)
        checkbox_item.setData(Qt.UserRole, result)
        self.csv_results_list.setItem(row, 0, checkbox_item)
        
        frame_name = os.path.basename(result.metadata.file_path)
        frame_item = QTableWidgetItem(frame_name)
        frame_item.setFlags(frame_item.flags() & ~Qt.ItemIsEditable)
        self.csv_results_list.setItem(row, 1, frame_item)
        
        status_item = QTableWidgetItem("Ready")
        status_item.setFlags(status_item.flags() & ~Qt.ItemIsEditable)
        self.csv_results_list.setItem(row, 2, status_item)
    
    def _update_csv_tab_title(self):
        """Update CSV tab title with count"""
        count = len(self.csv_results)
        self.csv_tab_widget.setTabText(1, f" CSV List ({count})")
    
    def _on_csv_checkbox_changed(self, item):
        """Handle CSV list checkbox changes"""
        if item.column() != 0:
            return
        
        row = item.row()
        status_item = self.csv_results_list.item(row, 2)
        
        if status_item is None:
            status_item = QTableWidgetItem("Ready")
            status_item.setFlags(status_item.flags() & ~Qt.ItemIsEditable)
            self.csv_results_list.setItem(row, 2, status_item)
            
        if item.checkState() == Qt.Checked:
            status_item.setText("Ready")
            status_item.setBackground(QColor("#E8F5E8"))
        else:
            status_item.setText("Excluded")
            status_item.setBackground(QColor("#FFE8E8"))
    
    def _remove_from_csv(self):
        """Remove selected items from CSV list"""
        rows_to_remove = []
        for row in range(self.csv_results_list.rowCount()):
            item = self.csv_results_list.item(row, 0)
            if item.checkState() == Qt.Checked:
                rows_to_remove.append(row)
        
        if not rows_to_remove:
            QMessageBox.warning(self, "Warning", "No items selected for removal")
            return
        
        for row in reversed(rows_to_remove):
            if row < len(self.csv_results):
                self.csv_results.pop(row)
            self.csv_results_list.removeRow(row)
        
        self._update_csv_tab_title()
        
        QMessageBox.information(
            self, 
            "Success", 
            f"Removed {len(rows_to_remove)} items from CSV list"
        )
    
    def _clear_csv_list(self):
        """Clear all items from CSV list"""
        if not self.csv_results:
            QMessageBox.information(self, "Info", "CSV list is already empty")
            return
        
        reply = QMessageBox.question(
            self, 
            "Confirm Clear", 
            "Are you sure you want to clear all items from the CSV list?",
            QMessageBox.Yes | QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            self.csv_results.clear()
            self.csv_results_list.setRowCount(0)
            self._update_csv_tab_title()
            
            QMessageBox.information(self, "Success", "CSV list cleared")
    
    def _on_qa_checkbox_changed(self, state):
        """Handle Q&A checkbox state changes"""
        self.qa_textbox.setEnabled(state == Qt.Checked)
        if state != Qt.Checked:
            self.qa_textbox.clear()
    
    def _export_csv_list(self):
        """Export CSV list to file with map-based format"""
        if not self.csv_results:
            QMessageBox.warning(self, "Warning", "CSV list is empty")
            return
        
        checked_results = []
        for row in range(self.csv_results_list.rowCount()):
            item = self.csv_results_list.item(row, 0)
            if item.checkState() == Qt.Checked:
                result = item.data(Qt.UserRole)
                checked_results.append(result)
        
        if not checked_results:
            QMessageBox.warning(self, "Warning", "No items are checked for export")
            return
        
        if len(checked_results) > 100:
            QMessageBox.warning(
                self, 
                "Warning", 
                f"You have selected {len(checked_results)} results. Maximum allowed is 100.\nPlease uncheck some items and try again."
            )
            return
        
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        
        result_folder = os.path.join(os.getcwd(), "result")
        if not os.path.exists(result_folder):
            os.makedirs(result_folder)
        
        csv_filename = f"submission_{timestamp}.csv"
        csv_path = os.path.join(result_folder, csv_filename)
        
        counter = 1
        original_path = csv_path
        while os.path.exists(csv_path):
            csv_filename = f"submission_{timestamp}_{counter}.csv"
            csv_path = os.path.join(result_folder, csv_filename)
            counter += 1
        
        try:
            qa_enabled = self.qa_checkbox.isChecked()
            qa_data = self.qa_textbox.text().strip() if qa_enabled else ""
            
            csv_lines = []
            for result in checked_results:
                folder_name = result.metadata.folder_name
                
                image_name = result.metadata.image_name
                frame_idx = os.path.splitext(image_name)[0]
                
                map_csv_name = f"{folder_name}.csv"
                
                if qa_enabled and qa_data:
                    csv_lines.append(f"{map_csv_name},{frame_idx},\"{qa_data}\"")
                else:
                    csv_lines.append(f"{map_csv_name},{frame_idx}")
            
            with open(csv_path, 'w', encoding='utf-8') as f:
                f.write('\n'.join(csv_lines))
            
            format_info = "[map_csv_filename, frame_idx]"
            if qa_enabled and qa_data:
                format_info = "[map_csv_filename, frame_idx, \"qa_data\"]"
            
            QMessageBox.information(
                self,
                "Success",
                f"Successfully exported {len(checked_results)} results!\n\nFile saved to: result/{csv_filename}\nFull path: {csv_path}\n\nFormat: {format_info}\n\nCSV list has been cleared."
            )
            
            self.csv_results.clear()
            self.csv_results_list.setRowCount(0)
            self._update_csv_tab_title()
            
        except Exception as e:
            QMessageBox.critical(self, "Export Error", f"Failed to export CSV:\n{str(e)}")
    
    def _get_full_image_pixmap(self, metadata, search_result=None) -> QPixmap:
        """
        Get full image pixmap from unified index or fallback to original file
        Enhanced with multi-strategy approach similar to ChatInterface
        
        Args:
            metadata: KeyframeMetadata object  
            search_result: Optional SearchResult with unified_index attribute
            
        Returns:
            QPixmap object or None if image cannot be loaded
        """
        try:
            # PATCH: Multi-strategy system reference recovery
            if not hasattr(self, 'system') or self.system is None:
                if not self._recover_system_reference():
                    debug_msg = " Failed to recover system reference - using direct .rvdb access"
                    if hasattr(self, 'logger') and self.logger:
                        self.logger.warning(debug_msg)

            # Strategy 1: Try unified index via search_result.unified_index
            unified_index_value = None
            if search_result is not None and hasattr(search_result, 'unified_index'):
                unified_index_value = search_result.unified_index
                
            if (unified_index_value is not None and
                hasattr(self, 'system') and self.system and
                hasattr(self.system, 'unified_builder') and 
                self.system.unified_builder and 
                self.system.unified_builder.unified_index and 
                self.system.unified_builder.unified_index.is_loaded):
                
                if hasattr(self, 'logger') and self.logger:
                    self.logger.info(f" Strategy 1: Unified index available - trying to get image for frame {unified_index_value}")
                
                # Try full image first
                full_image_bytes = self.system.unified_builder.get_full_image_fast(unified_index_value)
                if full_image_bytes:
                    # Check if it's valid JPEG
                    if full_image_bytes[:2] == b'\xff\xd8':
                        pixmap = QPixmap()
                        if pixmap.loadFromData(full_image_bytes):
                            if hasattr(self, 'logger') and self.logger:
                                self.logger.info(f" Strategy 1: Successfully loaded full JPEG image: {pixmap.size()}")
                            return pixmap
                    else:
                        # Try LZ4 decompression (old format)
                        try:
                            import lz4.frame
                            decompressed_bytes = lz4.frame.decompress(full_image_bytes)
                            pixmap = QPixmap()
                            if pixmap.loadFromData(decompressed_bytes):
                                if hasattr(self, 'logger') and self.logger:
                                    self.logger.info(f" Strategy 1: Successfully loaded decompressed image: {pixmap.size()}")
                                return pixmap
                        except Exception:
                            pass
                else:
                    # Try thumbnail fallback from unified index
                    thumbnail_array = self.system.unified_builder.get_thumbnail_fast(unified_index_value)
                    if thumbnail_array is not None:
                        height, width, channel = thumbnail_array.shape
                        bytes_per_line = 3 * width
                        q_image = QImage(thumbnail_array.data, width, height, bytes_per_line, QImage.Format_RGB888)
                        pixmap = QPixmap.fromImage(q_image)
                        if hasattr(self, 'logger') and self.logger:
                            self.logger.info(f" Strategy 1: Successfully loaded thumbnail from unified index: {pixmap.size()}")
                        return pixmap

            # Strategy 2: Try to find frame in unified index by metadata matching
            if (hasattr(self, 'system') and self.system and
                hasattr(self.system, 'unified_builder') and 
                self.system.unified_builder and 
                self.system.unified_builder.unified_index and 
                self.system.unified_builder.unified_index.is_loaded):
                
                if hasattr(self, 'logger') and self.logger:
                    self.logger.info(f" Strategy 2: Searching unified index metadata for matching frame")
                
                try:
                    metadata_list = self.system.unified_builder.unified_index.metadata_list
                    if metadata_list:
                        for idx, meta_dict in enumerate(metadata_list):
                            if (meta_dict.get('file_path') == metadata.file_path or
                                (meta_dict.get('folder_name') == metadata.folder_name and 
                                 meta_dict.get('image_name') == metadata.image_name)):
                                
                                # Found matching frame, try to get full image
                                full_image_bytes = self.system.unified_builder.get_full_image_fast(idx)
                                if full_image_bytes:
                                    # Check if it's valid JPEG
                                    if full_image_bytes[:2] == b'\xff\xd8':
                                        pixmap = QPixmap()
                                        if pixmap.loadFromData(full_image_bytes):
                                            if hasattr(self, 'logger') and self.logger:
                                                self.logger.info(f" Strategy 2: Found and loaded full JPEG image at index {idx}")
                                            return pixmap
                                    else:
                                        # Try LZ4 decompression
                                        try:
                                            import lz4.frame
                                            decompressed_bytes = lz4.frame.decompress(full_image_bytes)
                                            pixmap = QPixmap()
                                            if pixmap.loadFromData(decompressed_bytes):
                                                if hasattr(self, 'logger') and self.logger:
                                                    self.logger.info(f" Strategy 2: Found and loaded decompressed image at index {idx}")
                                                return pixmap
                                        except Exception:
                                            pass
                                
                                # Try thumbnail fallback
                                thumbnail_array = self.system.unified_builder.get_thumbnail_fast(idx)
                                if thumbnail_array is not None:
                                    height, width, channel = thumbnail_array.shape
                                    bytes_per_line = 3 * width
                                    q_image = QImage(thumbnail_array.data, width, height, bytes_per_line, QImage.Format_RGB888)
                                    pixmap = QPixmap.fromImage(q_image)
                                    if hasattr(self, 'logger') and self.logger:
                                        self.logger.info(f" Strategy 2: Found and loaded thumbnail at index {idx}")
                                    return pixmap
                                break
                except Exception as e:
                    if hasattr(self, 'logger') and self.logger:
                        self.logger.warning(f"Strategy 2 failed: {e}")

            # Strategy 3: Direct .rvdb access as fallback (similar to ChatInterface)
            if hasattr(self, 'logger') and self.logger:
                self.logger.info(f" Strategy 3: Trying direct .rvdb access")
            
            direct_pixmap = self._get_image_from_direct_rvdb_for_search(metadata, search_result)
            if direct_pixmap:
                if hasattr(self, 'logger') and self.logger:
                    self.logger.info(f" Strategy 3: Successfully loaded image from direct .rvdb access")
                return direct_pixmap

            # Strategy 4: Fallback to original file
            if hasattr(metadata, 'file_path') and os.path.exists(metadata.file_path):
                if hasattr(self, 'logger') and self.logger:
                    self.logger.info(f" Strategy 4: Using original file: {metadata.file_path}")
                return QPixmap(metadata.file_path)
            
            # Strategy 5: Create placeholder thumbnail with metadata info
            if hasattr(self, 'logger') and self.logger:
                self.logger.info(" Strategy 5: Creating placeholder thumbnail - no images found")
            placeholder = self._create_placeholder_thumbnail(metadata)
            if hasattr(self, 'logger') and self.logger:
                self.logger.info(f" Strategy 5: Created placeholder: {placeholder.size()}")
            return placeholder
            
        except Exception as e:
            if hasattr(self, 'logger') and self.logger:
                self.logger.warning(f"Failed to get full image: {e}")
            # Final fallback - create placeholder
            return self._create_placeholder_thumbnail(metadata)
    
    def _create_placeholder_thumbnail(self, metadata, size=(120, 90)) -> QPixmap:
        """
        Create placeholder thumbnail with metadata information
        
        Args:
            metadata: KeyframeMetadata object
            size: Tuple of (width, height) for thumbnail
            
        Returns:
            QPixmap with metadata information displayed
        """
        try:
            width, height = size
            placeholder = QPixmap(width, height)
            placeholder.fill(QColor("#F0F0F0"))
            
            painter = QPainter(placeholder)
            painter.setRenderHint(QPainter.Antialiasing)
            
            # Background gradient
            gradient = QLinearGradient(0, 0, 0, height)
            gradient.setColorAt(0, QColor("#E8E8E8"))
            gradient.setColorAt(1, QColor("#D0D0D0"))
            painter.fillRect(0, 0, width, height, QBrush(gradient))
            
            # Border
            painter.setPen(QPen(QColor("#CCCCCC"), 1))
            painter.drawRect(0, 0, width-1, height-1)
            
            # Text content
            painter.setPen(QColor("#666666"))
            font = QFont("Arial", 8, QFont.Bold)
            painter.setFont(font)
            
            # Extract filename from metadata
            if hasattr(metadata, 'image_name') and metadata.image_name:
                filename = metadata.image_name
            elif hasattr(metadata, 'file_path') and metadata.file_path:
                filename = os.path.basename(metadata.file_path)
            else:
                filename = "Unknown"
            
            # Truncate filename if too long
            if len(filename) > 15:
                filename = filename[:12] + "..."
            
            # Draw filename
            painter.drawText(5, 15, filename)
            
            # Draw folder info
            if hasattr(metadata, 'folder_name') and metadata.folder_name:
                folder = metadata.folder_name
                if len(folder) > 15:
                    folder = folder[:12] + "..."
                painter.setPen(QColor("#888888"))
                font.setPointSize(7)
                painter.setFont(font)
                painter.drawText(5, 30, f" {folder}")
            
            # Draw frame ID
            if hasattr(metadata, 'frame_id') and metadata.frame_id:
                painter.drawText(5, 45, f" #{metadata.frame_id}")
            
            # Draw "No Preview" indicator
            painter.setPen(QColor("#AAAAAA"))
            font.setPointSize(9)
            font.setBold(False)
            painter.setFont(font)
            painter.drawText(5, height-10, " No Preview")
            
            painter.end()
            return placeholder
            
        except Exception as e:
            # Fallback to simple placeholder
            placeholder = QPixmap(width, height)
            placeholder.fill(QColor("#F5F5F5"))
            painter = QPainter(placeholder)
            painter.setPen(QColor("#CCCCCC"))
            painter.drawText(5, height//2, "No Image")
            painter.end()
            return placeholder
    
    def _get_image_from_direct_rvdb_for_search(self, metadata, search_result=None) -> Optional[QPixmap]:
        """
        Get image from .rvdb file directly as fallback for search results
        Adapted from ChatInterface's _get_image_from_direct_rvdb method
        """
        try:
            # Get unified_index value from search_result or try to find it
            unified_index_value = None
            if search_result is not None and hasattr(search_result, 'unified_index'):
                unified_index_value = search_result.unified_index
            
            # If no unified_index available, try to find .rvdb files and search by metadata
            import glob
            rvdb_files = glob.glob("*.rvdb")
            if not rvdb_files:
                return None
            
            from unified_index import UnifiedIndex, UnifiedIndexConfig
            config = UnifiedIndexConfig(memory_map=True)
            temp_index = UnifiedIndex(config)
            temp_index.load_unified_index(rvdb_files[0])
            
            # If we have unified_index_value, use it directly
            if unified_index_value is not None:
                # Try to get full image first
                full_image_bytes = temp_index.get_full_image(unified_index_value)
                if full_image_bytes:
                    # Check if it's valid JPEG
                    if full_image_bytes[:2] == b'\xff\xd8':
                        pixmap = QPixmap()
                        if pixmap.loadFromData(full_image_bytes):
                            temp_index.close()
                            return pixmap
                    else:
                        # Try LZ4 decompression (old format)
                        try:
                            import lz4.frame
                            decompressed_bytes = lz4.frame.decompress(full_image_bytes)
                            pixmap = QPixmap()
                            if pixmap.loadFromData(decompressed_bytes):
                                temp_index.close()
                                return pixmap
                        except Exception:
                            pass
                
                # Try thumbnail as fallback
                thumbnail_array = temp_index.get_thumbnail(unified_index_value)
                if thumbnail_array is not None:
                    height, width, channel = thumbnail_array.shape
                    bytes_per_line = 3 * width
                    q_image = QImage(thumbnail_array.data, width, height, bytes_per_line, QImage.Format_RGB888)
                    pixmap = QPixmap.fromImage(q_image)
                    temp_index.close()
                    return pixmap
            else:
                # Search by metadata if no unified_index available
                if hasattr(temp_index, 'metadata_list') and temp_index.metadata_list:
                    for idx, meta_dict in enumerate(temp_index.metadata_list):
                        if (meta_dict.get('file_path') == metadata.file_path or
                            (meta_dict.get('folder_name') == metadata.folder_name and 
                             meta_dict.get('image_name') == metadata.image_name)):
                            
                            # Found matching frame, try to get full image
                            full_image_bytes = temp_index.get_full_image(idx)
                            if full_image_bytes:
                                # Check if it's valid JPEG
                                if full_image_bytes[:2] == b'\xff\xd8':
                                    pixmap = QPixmap()
                                    if pixmap.loadFromData(full_image_bytes):
                                        temp_index.close()
                                        return pixmap
                                else:
                                    # Try LZ4 decompression
                                    try:
                                        import lz4.frame
                                        decompressed_bytes = lz4.frame.decompress(full_image_bytes)
                                        pixmap = QPixmap()
                                        if pixmap.loadFromData(decompressed_bytes):
                                            temp_index.close()
                                            return pixmap
                                    except Exception:
                                        pass
                            
                            # Try thumbnail fallback
                            thumbnail_array = temp_index.get_thumbnail(idx)
                            if thumbnail_array is not None:
                                height, width, channel = thumbnail_array.shape
                                bytes_per_line = 3 * width
                                q_image = QImage(thumbnail_array.data, width, height, bytes_per_line, QImage.Format_RGB888)
                                pixmap = QPixmap.fromImage(q_image)
                                temp_index.close()
                                return pixmap
                            break
            
            temp_index.close()
            return None
            
        except Exception as e:
            if hasattr(self, 'logger') and self.logger:
                self.logger.warning(f"Failed direct .rvdb access for search results: {e}")
            return None

# ================================================================================
# CHAT INTERFACE (OpenAI Only)
# ================================================================================

class ChatInterface(QWidget):
    """Enhanced OpenAI Chat Interface with Results Panel"""
    
    search_requested = pyqtSignal(str)  # chat query
    frame_selected = pyqtSignal(str)   # frame selection signal
    
    def __init__(self, retrieval_system: EnhancedRetrievalSystem, parent=None):
        """Initialize enhanced chat interface"""
        super().__init__(parent)
        
        self.system = retrieval_system
        self.chat_history = []
        self.worker_threads = []
        self.selected_frames = []
        self.csv_frames = []
        self.current_search_results = []
        self._search_in_progress = False  # Fixed: Track search state to prevent double triggering
        
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup enhanced chat interface UI with results panel"""
        main_layout = QHBoxLayout(self)
        
        # Left side: Chat interface
        chat_widget = QWidget()
        chat_layout = QVBoxLayout(chat_widget)
        
        # Chat history display
        self.chat_display = QTextEdit()
        self.chat_display.setReadOnly(True)
        self.chat_display.setMinimumHeight(400)
        self.chat_display.setStyleSheet("""
            QTextEdit {
                background-color: #FAFAFA;
                border: 1px solid #E0E0E0;
                border-radius: 8px;
                padding: 10px;
                font-family: 'Segoe UI', Arial, sans-serif;
            }
        """)
        
        # Frame context controls
        context_layout = QHBoxLayout()
        context_layout.addWidget(QLabel("Include in conversation:"))
        
        self.include_selected_checkbox = QCheckBox("Selected frames")
        self.include_selected_checkbox.setChecked(True)
        self.include_csv_checkbox = QCheckBox("CSV frames")
        self.include_csv_checkbox.setChecked(False)
        
        context_layout.addWidget(self.include_selected_checkbox)
        context_layout.addWidget(self.include_csv_checkbox)
        context_layout.addStretch()
        
        # Input area
        input_layout = QHBoxLayout()
        
        self.chat_input = QLineEdit()
        self.chat_input.setPlaceholderText("Ask me about the keyframes... (e.g., 'Show me scenes with people talking')")
        self.chat_input.setMinimumHeight(40)
        
        self.send_button = QPushButton("Send")
        self.send_button.setMinimumSize(80, 40)
        
        input_layout.addWidget(self.chat_input)
        input_layout.addWidget(self.send_button)
        
        # Quick questions
        quick_questions_layout = QHBoxLayout()
        quick_questions_layout.addWidget(QLabel("Quick questions:"))
        
        quick_questions = [
            "What scenes have cars?",
            "Show me people talking",
            "Find outdoor scenes",
            "Describe this image"
        ]
        
        for question in quick_questions:
            btn = QPushButton(question)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #FFF3E0;
                    color: #d67302;
                    border: 1px solid #FFB74D;
                    border-radius: 15px;
                    padding: 5px 10px;
                    font-size: 12px;
                }
                QPushButton:hover {
                    background-color: #FFE0B2;
                }
            """)
            btn.clicked.connect(partial(self._send_quick_question, question))
            quick_questions_layout.addWidget(btn)
        
        quick_questions_layout.addStretch()
        
        chat_layout.addWidget(QLabel(" Chat with the System"))
        chat_layout.addWidget(self.chat_display)
        chat_layout.addLayout(context_layout)
        chat_layout.addLayout(quick_questions_layout)
        chat_layout.addLayout(input_layout)
        
        # Right side: Results panel
        self.results_panel = self._create_results_panel()
        
        # Splitter to allow resizing
        splitter = QSplitter(Qt.Horizontal)
        splitter.addWidget(chat_widget)
        splitter.addWidget(self.results_panel)
        splitter.setSizes([350, 650])
        splitter.setStretchFactor(0, 0)
        splitter.setStretchFactor(1, 1)
        
        main_layout.addWidget(splitter)
        
        # Connect signals
        self.send_button.clicked.connect(self._send_message)
        self.chat_input.returnPressed.connect(self._send_message)
        
        # Add welcome message
        self._add_system_message("Hello! I can help you search through keyframes using natural language. Try asking me about specific scenes, objects, or actions.")
    
    def _create_results_panel(self):
        """Create the results panel widget"""
        panel = QWidget()
        layout = QVBoxLayout(panel)
        
        # Panel header
        header_layout = QHBoxLayout()
        header_layout.addWidget(QLabel(" Search Results & Frame Selection"))
        
        # Toggle visibility button
        self.toggle_panel_btn = QPushButton("Hide")
        self.toggle_panel_btn.setMaximumWidth(60)
        self.toggle_panel_btn.clicked.connect(self._toggle_results_panel)
        header_layout.addWidget(self.toggle_panel_btn)
        
        layout.addLayout(header_layout)
        
        # Tabs for different content
        self.results_tabs = QTabWidget()
        
        # Tab 1: Search Results
        self.search_results_tab = self._create_search_results_tab()
        self.results_tabs.addTab(self.search_results_tab, "Search Results")
        
        # Tab 2: Selected Frames
        self.selected_frames_tab = self._create_selected_frames_tab()
        self.results_tabs.addTab(self.selected_frames_tab, "Selected Frames")
        
        # Tab 3: CSV Frames  
        self.csv_frames_tab = self._create_csv_frames_tab()
        self.results_tabs.addTab(self.csv_frames_tab, "CSV Frames")
        
        layout.addWidget(self.results_tabs)
        
        panel.setMinimumWidth(550)
        panel.setMaximumWidth(1200)
        return panel
    
    def _create_search_results_tab(self):
        """Create search results tab"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        # Results info
        self.results_info_label = QLabel("No search results yet")
        layout.addWidget(self.results_info_label)
        
        # Results scroll area
        self.search_results_scroll = QScrollArea()
        self.search_results_scroll.setWidgetResizable(True)
        self.search_results_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        
        self.search_results_widget = QWidget()
        self.search_results_layout = QVBoxLayout(self.search_results_widget)
        self.search_results_scroll.setWidget(self.search_results_widget)
        
        layout.addWidget(self.search_results_scroll)
        
        return widget
    
    def _create_selected_frames_tab(self):
        """Create selected frames tab"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        # Header with count - Fixed: Made buttons wider
        header_layout = QHBoxLayout()
        self.selected_count_label = QLabel("Selected: 0 frames")
        header_layout.addWidget(self.selected_count_label)
        
        clear_selected_btn = QPushButton("Clear All")
        clear_selected_btn.setMinimumWidth(100)  # Fixed: Wider button
        clear_selected_btn.clicked.connect(self._clear_selected_frames)
        header_layout.addWidget(clear_selected_btn)
        
        layout.addLayout(header_layout)
        
        # Selected frames scroll area
        self.selected_scroll = QScrollArea()
        self.selected_scroll.setWidgetResizable(True)
        self.selected_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        
        self.selected_widget = QWidget()
        self.selected_layout = QVBoxLayout(self.selected_widget)
        self.selected_scroll.setWidget(self.selected_widget)
        
        layout.addWidget(self.selected_scroll)
        
        return widget
    
    def _create_csv_frames_tab(self):
        """Create CSV frames tab"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        # Header with count and load button - Fixed: Made buttons wider
        header_layout = QHBoxLayout()
        self.csv_count_label = QLabel("CSV: 0 frames")
        header_layout.addWidget(self.csv_count_label)
        
        load_csv_btn = QPushButton("Load CSV")
        load_csv_btn.setMinimumWidth(100)  # Fixed: Wider button
        load_csv_btn.clicked.connect(self._load_csv_frames)
        header_layout.addWidget(load_csv_btn)
        
        layout.addLayout(header_layout)
        
        # CSV frames scroll area
        self.csv_scroll = QScrollArea()
        self.csv_scroll.setWidgetResizable(True)
        self.csv_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        
        self.csv_widget = QWidget()
        self.csv_layout = QVBoxLayout(self.csv_widget)
        self.csv_scroll.setWidget(self.csv_widget)
        
        layout.addWidget(self.csv_scroll)
        
        return widget
    
    def _toggle_results_panel(self):
        """Toggle results panel visibility"""
        if self.results_panel.isVisible():
            self.results_panel.hide()
            self.toggle_panel_btn.setText("Show")
        else:
            self.results_panel.show()
            self.toggle_panel_btn.setText("Hide")
    
    def _clear_selected_frames(self):
        """Clear all selected frames"""
        self.selected_frames.clear()
        self._update_selected_frames_display()
    
    def _load_csv_frames(self):
        """Load frames from CSV file"""
        try:
            file_path, _ = QFileDialog.getOpenFileName(
                self, "Select CSV File", "", "CSV Files (*.csv)"
            )
            if file_path:
                import pandas as pd
                df = pd.read_csv(file_path)
                self.csv_frames = []
                for _, row in df.iterrows():
                    frame_id = f"{row.get('folder_name', 'unknown')}:{row.get('frame_id', 0)}"
                    self.csv_frames.append({
                        'id': frame_id,
                        'file_path': row.get('file_path', ''),
                        'folder_name': row.get('folder_name', ''),
                        'frame_id': row.get('frame_id', 0)
                    })
                self._update_csv_frames_display()
                QMessageBox.information(self, "Success", f"Loaded {len(self.csv_frames)} frames from CSV")
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Failed to load CSV: {str(e)}")
    
    def _update_search_results_display(self, search_results):
        """Update the search results display in the results panel"""
        try:
            self.current_search_results = search_results
            
            self.results_info_label.setText(f"Found {len(search_results)} results")
            
            # Clear existing widgets
            for i in reversed(range(self.search_results_layout.count())):
                child = self.search_results_layout.itemAt(i).widget()
                if child:
                    child.setParent(None)
            
            # Add new widgets
            for i, result in enumerate(search_results):
                frame_widget = self._create_frame_widget(result, i, 'search')
                self.search_results_layout.addWidget(frame_widget)
            
            self.search_results_layout.addStretch()
            
            # Force widget and scroll area updates
            self.search_results_widget.updateGeometry()
            self.search_results_scroll.updateGeometry()
            self.search_results_widget.update()
            self.search_results_scroll.update()
            
        except Exception as e:
            if hasattr(self, 'logger') and self.logger:
                self.logger.error(f"Failed to update search results display: {e}")
    
    def _update_selected_frames_display(self):
        """Update the selected frames display"""
        try:
            self.selected_count_label.setText(f"Selected: {len(self.selected_frames)} frames")
            
            for i in reversed(range(self.selected_layout.count())):
                child = self.selected_layout.itemAt(i).widget()
                if child:
                    child.setParent(None)
            
            for i, frame_data in enumerate(self.selected_frames):
                frame_widget = self._create_frame_widget(frame_data, i, 'selected')
                self.selected_layout.addWidget(frame_widget)
            
            self.selected_layout.addStretch()
            
        except Exception as e:
            pass
    
    def _update_csv_frames_display(self):
        """Update the CSV frames display"""
        try:
            self.csv_count_label.setText(f"CSV: {len(self.csv_frames)} frames")
            
            for i in reversed(range(self.csv_layout.count())):
                child = self.csv_layout.itemAt(i).widget()
                if child:
                    child.setParent(None)
            
            for i, frame_data in enumerate(self.csv_frames):
                frame_widget = self._create_frame_widget(frame_data, i, 'csv')
                self.csv_layout.addWidget(frame_widget)
            
            self.csv_layout.addStretch()
            
        except Exception as e:
            pass
    
    def _create_frame_widget(self, frame_data, index, source_type):
        """Create a widget for displaying a frame with selection capability"""
        try:
            frame_widget = QFrame()
            frame_widget.setFrameStyle(QFrame.StyledPanel)
            frame_widget.setStyleSheet("""
                QFrame {
                    border: 1px solid #ddd;
                    border-radius: 8px;
                    margin: 2px;
                    background-color: white;
                }
                QFrame:hover {
                    border-color: #d67302;
                    background-color: #fff8f0;
                }
            """)
            
            layout = QHBoxLayout(frame_widget)
            layout.setContentsMargins(10, 10, 10, 10)
            frame_widget.setMinimumHeight(110)
            frame_widget.setMaximumHeight(130)
            
            # Get file path based on source type
            if source_type == 'search' and hasattr(frame_data, 'metadata'):
                file_path = frame_data.metadata.file_path
                frame_id = f"{frame_data.metadata.folder_name}:{frame_data.metadata.frame_id}"
                score = getattr(frame_data, 'similarity_score', 0.0)
            else:
                file_path = frame_data.get('file_path', '')
                frame_id = frame_data.get('id', f"frame_{index}")
                score = frame_data.get('similarity_score', 0.0)
            
            # Thumbnail
            thumbnail_label = QLabel()
            thumbnail_label.setFixedSize(120, 90)
            thumbnail_label.setStyleSheet("border: 1px solid #ccc; border-radius: 4px;")
            
            # PATCH: Try unified index first, fallback to original file
            pixmap = None
            
            # Try to get image from unified index if available
            unified_index_value = None
            if source_type == 'search' and hasattr(frame_data, 'unified_index'):
                unified_index_value = frame_data.unified_index
            elif source_type != 'search' and isinstance(frame_data, dict):
                # For selected frames, try to get unified_index from the dict
                unified_index_value = frame_data.get('unified_index')
            else:
                unified_index_value = None
                
            if (unified_index_value is not None and
                hasattr(self, 'system') and self.system and
                hasattr(self.system, 'unified_builder') and 
                self.system.unified_builder and 
                self.system.unified_builder.unified_index and 
                self.system.unified_builder.unified_index.is_loaded):
                
                # Try full image first
                full_image_bytes = self.system.unified_builder.get_full_image_fast(unified_index_value)
                if full_image_bytes:
                    # Check if it's valid JPEG
                    if full_image_bytes[:2] == b'\xff\xd8':
                        pixmap = QPixmap()
                        pixmap.loadFromData(full_image_bytes)
                    else:
                        # Try LZ4 decompression (old format)
                        try:
                            import lz4.frame
                            decompressed_bytes = lz4.frame.decompress(full_image_bytes)
                            pixmap = QPixmap()
                            pixmap.loadFromData(decompressed_bytes)
                        except Exception:
                            pixmap = None
                else:
                    # Try thumbnail
                    thumbnail_array = self.system.unified_builder.get_thumbnail_fast(unified_index_value)
                    if thumbnail_array is not None:
                        height, width, channel = thumbnail_array.shape
                        bytes_per_line = 3 * width
                        q_image = QImage(thumbnail_array.data, width, height, bytes_per_line, QImage.Format_RGB888)
                        pixmap = QPixmap.fromImage(q_image)
            
            # Fallback to original file if unified index failed
            if not pixmap or pixmap.isNull():
                if os.path.exists(file_path):
                    pixmap = QPixmap(file_path)
            
            # Display image or fallback text
            if pixmap and not pixmap.isNull():
                scaled_pixmap = pixmap.scaled(120, 90, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                thumbnail_label.setPixmap(scaled_pixmap)
                thumbnail_label.setAlignment(Qt.AlignCenter)
            else:
                # PATCH: Try direct .rvdb access as last resort
                direct_pixmap = self._get_image_from_direct_rvdb(frame_data, source_type)
                if direct_pixmap:
                    scaled_pixmap = direct_pixmap.scaled(120, 90, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                    thumbnail_label.setPixmap(scaled_pixmap)
                    thumbnail_label.setAlignment(Qt.AlignCenter)
                else:
                    thumbnail_label.setText("Missing")
                    thumbnail_label.setAlignment(Qt.AlignCenter)
            
            layout.addWidget(thumbnail_label)
            
            # Info layout
            info_layout = QVBoxLayout()
            
            # Frame ID
            id_label = QLabel(frame_id)
            id_label.setStyleSheet("font-weight: bold; font-size: 14px;")
            info_layout.addWidget(id_label)
            
            # File name
            file_name = os.path.basename(file_path) if file_path else "Unknown"
            file_label = QLabel(file_name)
            file_label.setStyleSheet("font-size: 12px; color: #666;")
            file_label.setWordWrap(True)
            info_layout.addWidget(file_label)
            
            # Score (if available)
            if score > 0:
                score_label = QLabel(f"Score: {score:.3f}")
                score_label.setStyleSheet("font-size: 11px; color: #888;")
                info_layout.addWidget(score_label)
            
            layout.addLayout(info_layout)
            
            # Action buttons - Fixed: Made buttons wider
            button_layout = QVBoxLayout()
            
            if source_type == 'search':
                select_btn = QPushButton("Select")
                select_btn.setMinimumWidth(100)  # Fixed: Wider button
                select_btn.setMinimumHeight(30)
                select_btn.clicked.connect(partial(self._select_frame, frame_data))
                button_layout.addWidget(select_btn)
            
            if source_type == 'selected':
                remove_btn = QPushButton("Remove")
                remove_btn.setMinimumWidth(100)  # Fixed: Wider button
                remove_btn.setMinimumHeight(30)
                remove_btn.clicked.connect(partial(self._remove_selected_frame, index))
                button_layout.addWidget(remove_btn)
            
            if source_type == 'csv':
                add_btn = QPushButton("Add")
                add_btn.setMinimumWidth(100)  # Fixed: Wider button
                add_btn.setMinimumHeight(30)
                add_btn.clicked.connect(partial(self._add_csv_frame_to_selected, frame_data))
                button_layout.addWidget(add_btn)
            
            layout.addLayout(button_layout)
            
            return frame_widget
            
        except Exception as e:
            error_widget = QLabel(f"Error: {str(e)}")
            return error_widget
    
    def _select_frame(self, frame_data):
        """Select a frame from search results"""
        try:
            frame_id = f"{frame_data.metadata.folder_name}:{frame_data.metadata.frame_id}"
            if not any(f.get('id') == frame_id for f in self.selected_frames):
                selected_frame = {
                    'id': frame_id,
                    'file_path': frame_data.metadata.file_path,
                    'folder_name': frame_data.metadata.folder_name,
                    'frame_id': frame_data.metadata.frame_id,
                    'similarity_score': getattr(frame_data, 'similarity_score', 0.0),
                    'metadata': frame_data.metadata,
                    'unified_index': getattr(frame_data, 'unified_index', None)  # PATCH: Preserve unified_index
                }
                self.selected_frames.append(selected_frame)
                self._update_selected_frames_display()
                
                self.results_tabs.setCurrentIndex(1)
                
        except Exception as e:
            print(f"Error selecting frame: {e}")
    
    def _remove_selected_frame(self, index):
        """Remove a frame from selected frames"""
        try:
            if 0 <= index < len(self.selected_frames):
                self.selected_frames.pop(index)
                self._update_selected_frames_display()
        except Exception as e:
            print(f"Error removing selected frame: {e}")
    
    def _add_csv_frame_to_selected(self, frame_data):
        """Add a CSV frame to selected frames"""
        try:
            frame_id = frame_data.get('id')
            if not any(f.get('id') == frame_id for f in self.selected_frames):
                self.selected_frames.append(frame_data.copy())
                self._update_selected_frames_display()
                
                self.results_tabs.setCurrentIndex(1)
                
        except Exception as e:
            print(f"Error adding CSV frame to selected: {e}")
    
    def _send_message(self):
        """Send chat message"""
        message = self.chat_input.text().strip()
        if not message:
            return
        
        self.chat_input.clear()
        self._add_user_message(message)
        
        self._process_chat_request(message)
    
    def _send_quick_question(self, question: str):
        """Send quick question"""
        try:
            self.chat_input.setText(question)
            # Move cursor to end to avoid position errors
            cursor = self.chat_input.textCursor()
            cursor.movePosition(QTextCursor.End)
            self.chat_input.setTextCursor(cursor)
        except Exception as e:
            # Fallback: just set text without cursor manipulation
            self.chat_input.clear()
            self.chat_input.insertPlainText(question)
        self._send_message()
    
    def _add_user_message(self, message: str):
        """Add user message to chat display"""
        timestamp = time.strftime("%H:%M")
        html = f"""
        <div style="margin: 10px 0; text-align: right;">
            <span style="background-color: #d67302; color: white; padding: 8px 12px; border-radius: 18px; display: inline-block; max-width: 70%;">
                {message}
            </span>
            <br><small style="color: #666; margin-top: 5px;">{timestamp}</small>
        </div>
        """
        # Safe text append with cursor position handling
        try:
            # Move cursor to end before appending to prevent position errors
            cursor = self.chat_display.textCursor()
            cursor.movePosition(QTextCursor.End)
            self.chat_display.setTextCursor(cursor)
            self.chat_display.append(html)
        except Exception as e:
            # Fallback: use plain text if HTML fails
            try:
                self.chat_display.append(f"User: {message} ({timestamp})")
            except Exception:
                # Last resort: use insertPlainText
                self.chat_display.insertPlainText(f"\nUser: {message} ({timestamp})\n")
        self.chat_history.append({"type": "user", "message": message, "timestamp": timestamp})
    
    def _add_system_message(self, message: str):
        """Add system message to chat display"""
        timestamp = time.strftime("%H:%M")
        html = f"""
        <div style="margin: 10px 0; text-align: left;">
            <span style="background-color: #F5F5F5; color: #333; padding: 8px 12px; border-radius: 18px; display: inline-block; max-width: 70%; border: 1px solid #E0E0E0;">
                {message}
            </span>
            <br><small style="color: #666; margin-top: 5px;">{timestamp}</small>
        </div>
        """
        # Safe text append with cursor position handling
        try:
            # Move cursor to end before appending to prevent position errors
            cursor = self.chat_display.textCursor()
            cursor.movePosition(QTextCursor.End)
            self.chat_display.setTextCursor(cursor)
            self.chat_display.append(html)
        except Exception as e:
            # Fallback: use plain text if HTML fails
            try:
                self.chat_display.append(f"System: {message} ({timestamp})")
            except Exception:
                # Last resort: use insertPlainText
                self.chat_display.insertPlainText(f"\nSystem: {message} ({timestamp})\n")
        self.chat_history.append({"type": "system", "message": message, "timestamp": timestamp})
    
    def _process_chat_request(self, message: str):
        """Process chat request with frame context"""
        # Fixed: Prevent double triggering
        if self._search_in_progress:
            return
            
        self._search_in_progress = True
        self._add_system_message(" Let me think about that...")
        
        # Prepare frame context based on user preferences
        context_frames = []
        
        if self.include_selected_checkbox.isChecked() and self.selected_frames:
            context_frames.extend(self.selected_frames)
        
        if self.include_csv_checkbox.isChecked() and self.csv_frames:
            context_frames.extend(self.csv_frames)
        
        # Create worker thread for chat processing (OpenAI only)
        worker = WorkerThread(self.system.chat, message, context_frames if context_frames else None)
        worker.result_ready.connect(self._on_chat_result)
        worker.error_occurred.connect(self._on_chat_error)
        worker.finished.connect(lambda: self._cleanup_worker(worker))
        worker.start()
        
        if not hasattr(self, 'worker_threads'):
            self.worker_threads = []
        
        self.worker_threads.append(worker)
    
    def _cleanup_worker(self, worker):
        """Properly cleanup worker thread"""
        # Fixed: Reset search state
        self._search_in_progress = False
        
        try:
            if hasattr(self, 'worker_threads') and worker in self.worker_threads:
                self.worker_threads.remove(worker)
            
            if worker.isRunning():
                worker.quit()
                worker.wait(3000)
                
            if worker.isRunning():
                worker.terminate()
                worker.wait(1000)
                
        except Exception as e:
            print(f"Error cleaning up worker thread: {e}")
    
    def _on_chat_result(self, result):
        """Handle chat result from OpenAI ChatAgent"""
        # Remove thinking message
        self.chat_display.undo()
        
        # Handle both old string format and new dict format
        if isinstance(result, dict):
            response_content = result.get('response_content', 'No response content available')
            search_performed = result.get('search_performed', False)
            search_results = result.get('search_results', [])
            vision_analysis = result.get('vision_analysis', False)
            
            # Add main response
            self._add_system_message(response_content)
            
            # Fixed: Only update results panel, don't trigger main search
            if search_performed and search_results:
                count = len(search_results)
                search_info = f" Found {count} matching frames (view in Results panel on the right)"
                self._add_system_message(search_info)
                
                # Update the results panel display ONLY
                self._update_search_results_display(search_results)
                
                # Fixed: Don't emit search_requested to prevent double triggering
                # The results are already displayed in the chat panel
                
            if vision_analysis:
                # Check if we have structured vision analysis data
                vision_analysis_data = result.get('vision_analysis_data')
                if vision_analysis_data:
                    frame_count = len(vision_analysis_data.get('frame_analyses', []))
                    vision_info = f" Completed structured vision analysis on {frame_count} frame(s)."
                    self._add_system_message(vision_info)
                    
                    # Optional: Could log structured data for debugging
                    if hasattr(self, 'logger'):
                        self.logger.info(f"Vision analysis summary: {vision_analysis_data.get('summary', 'No summary')}")
                else:
                    vision_info = f" Performed vision analysis on selected frames."
                    self._add_system_message(vision_info)
                
        elif isinstance(result, str):
            # Old string format - backward compatibility
            self._add_system_message(result)
        else:
            # Fallback
            self._add_system_message(str(result))
    
    def _on_chat_error(self, error: str):
        """Handle chat error"""
        # Remove thinking message
        self.chat_display.undo()
        
        self._add_system_message(f" Sorry, I encountered an error: {error}")
    
    def set_selected_frames(self, selected_frames: List[KeyframeMetadata]):
        """Set currently selected frames for context in chat"""
        self.selected_frames = [frame.file_path for frame in selected_frames]
        
        if selected_frames:
            count = len(selected_frames)
            frame_info = []
            for frame in selected_frames[:3]:
                frame_info.append(f"{frame.folder_name}-{frame.frame_id}")
            
            if count > 3:
                frame_info.append(f"... and {count-3} more")
            
            frames_text = ", ".join(frame_info)
            self._add_system_message(f" I can now see your selected frames: {frames_text}. Feel free to ask questions about them!")
    
    def chat_with_frames(self, message: str, selected_frames: List[KeyframeMetadata] = None):
        """Chat about specific frames"""
        if selected_frames:
            self.set_selected_frames(selected_frames)
        
        self._add_user_message(message)
        self._process_chat_request(message)
    
    def cleanup_all_threads(self):
        """Clean up all running worker threads"""
        active_threads = []
        for worker in self.worker_threads[:]:
            if worker.isRunning():
                worker.cancel()
                active_threads.append(worker)
        
        for worker in active_threads:
            if not worker.wait(2000):
                worker.terminate()
                worker.wait(500)
        
        self.worker_threads.clear()
    
    def _get_image_from_direct_rvdb(self, frame_data, source_type) -> Optional[QPixmap]:
        """
        PATCH: Get image from .rvdb file directly as last resort
        
        This is a fallback method similar to the one in _get_full_image_pixmap
        but adapted for ChatInterface frame widgets.
        """
        try:
            # Get unified_index value from frame_data
            unified_index_value = None
            if source_type == 'search' and hasattr(frame_data, 'unified_index'):
                unified_index_value = frame_data.unified_index
            elif isinstance(frame_data, dict):
                unified_index_value = frame_data.get('unified_index')
                
            if unified_index_value is None:
                return None
            
            # Try to find .rvdb files in current directory
            import glob
            rvdb_files = glob.glob("*.rvdb")
            if not rvdb_files:
                return None
            
            from unified_index import UnifiedIndex, UnifiedIndexConfig
            config = UnifiedIndexConfig(memory_map=True)
            temp_index = UnifiedIndex(config)
            temp_index.load_unified_index(rvdb_files[0])
            
            # Try to get full image first
            full_image_bytes = temp_index.get_full_image(unified_index_value)
            if full_image_bytes:
                pixmap = QPixmap()
                if pixmap.loadFromData(full_image_bytes):
                    temp_index.close()
                    return pixmap
            
            # Try thumbnail as fallback
            thumbnail_array = temp_index.get_thumbnail(unified_index_value)
            if thumbnail_array is not None:
                height, width, channel = thumbnail_array.shape
                bytes_per_line = 3 * width
                q_image = QImage(thumbnail_array.data, width, height, bytes_per_line, QImage.Format_RGB888)
                pixmap = QPixmap.fromImage(q_image)
                temp_index.close()
                return pixmap
            
            temp_index.close()
            return None
            
        except Exception as e:
            print(f"Failed direct .rvdb access in ChatInterface: {e}")
            return None

# ================================================================================
# EXPORT DIALOG
# ================================================================================

class ExportDialog(QDialog):
    """Advanced Export Dialog - Dialog for exporting search results in various formats"""
    
    def __init__(self, results: List[SearchResult], parent=None):
        """Initialize export dialog"""
        super().__init__(parent)
        
        self.results = results
        self.export_path = ""
        
        self._setup_ui()
        self.setModal(True)
        self.setWindowTitle("Export Search Results")
        self.resize(500, 400)
    
    def _setup_ui(self):
        """Setup export dialog UI"""
        layout = QVBoxLayout(self)
        
        # Title
        title = QLabel(f"Export {len(self.results)} Search Results")
        title.setFont(QFont("Arial", 14, QFont.Bold))
        layout.addWidget(title)
        
        # Export format selection
        format_group = QGroupBox("Export Format")
        format_layout = QVBoxLayout(format_group)
        
        self.format_csv = QCheckBox("CSV (Comma Separated Values)")
        self.format_json = QCheckBox("JSON (JavaScript Object Notation)")
        self.format_xlsx = QCheckBox("Excel Spreadsheet (.xlsx)")
        
        self.format_csv.setChecked(True)
        
        format_layout.addWidget(self.format_csv)
        format_layout.addWidget(self.format_json)
        format_layout.addWidget(self.format_xlsx)
        
        # Export options
        options_group = QGroupBox("Export Options")
        options_layout = QVBoxLayout(options_group)
        
        self.include_metadata = QCheckBox("Include full metadata")
        self.include_thumbnails = QCheckBox("Export thumbnail images")
        self.include_temporal = QCheckBox("Include temporal context")
        
        self.include_metadata.setChecked(True)
        
        options_layout.addWidget(self.include_metadata)
        options_layout.addWidget(self.include_thumbnails)
        options_layout.addWidget(self.include_temporal)
        
        # File selection
        file_group = QGroupBox("Output Location")
        file_layout = QHBoxLayout(file_group)
        
        self.file_path_edit = QLineEdit()
        self.file_path_edit.setPlaceholderText("Choose export location...")
        
        self.browse_button = QPushButton("Browse...")
        self.browse_button.clicked.connect(self._browse_location)
        
        file_layout.addWidget(self.file_path_edit)
        file_layout.addWidget(self.browse_button)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        self.export_button = QPushButton("Export")
        self.cancel_button = QPushButton("Cancel")
        
        self.export_button.clicked.connect(self._export_results)
        self.cancel_button.clicked.connect(self.reject)
        
        button_layout.addStretch()
        button_layout.addWidget(self.export_button)
        button_layout.addWidget(self.cancel_button)
        
        # Add to main layout
        layout.addWidget(format_group)
        layout.addWidget(options_group)
        layout.addWidget(file_group)
        layout.addStretch()
        layout.addLayout(button_layout)
    
    def _browse_location(self):
        """Browse for export location"""
        file_dialog = QFileDialog(self)
        file_dialog.setAcceptMode(QFileDialog.AcceptSave)
        file_dialog.setFileMode(QFileDialog.AnyFile)
        
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        default_name = f"search_results_{timestamp}"
        
        filters = []
        if self.format_csv.isChecked():
            filters.append("CSV Files (*.csv)")
        if self.format_json.isChecked():
            filters.append("JSON Files (*.json)")
        if self.format_xlsx.isChecked():
            filters.append("Excel Files (*.xlsx)")
        
        if filters:
            file_dialog.setNameFilters(filters)
        
        if file_dialog.exec_() == QFileDialog.Accepted:
            selected_files = file_dialog.selectedFiles()
            if selected_files:
                self.file_path_edit.setText(selected_files[0])
    
    def _export_results(self):
        """Export results with selected options"""
        if not self.file_path_edit.text().strip():
            QMessageBox.warning(self, "Warning", "Please select an export location.")
            return
        
        formats = []
        if self.format_csv.isChecked():
            formats.append("csv")
        if self.format_json.isChecked():
            formats.append("json")
        if self.format_xlsx.isChecked():
            formats.append("xlsx")
        
        if not formats:
            QMessageBox.warning(self, "Warning", "Please select at least one export format.")
            return
        
        export_options = {
            "include_metadata": self.include_metadata.isChecked(),
            "include_thumbnails": self.include_thumbnails.isChecked(),
            "include_temporal": self.include_temporal.isChecked()
        }
        
        try:
            base_path = Path(self.file_path_edit.text())
            base_name = base_path.stem
            base_dir = base_path.parent
            
            exported_files = []
            
            for format_type in formats:
                output_path = base_dir / f"{base_name}.{format_type}"
                
                self._export_to_format(self.results, str(output_path), format_type, export_options)
                exported_files.append(str(output_path))
            
            files_text = "\n".join(exported_files)
            QMessageBox.information(
                self, 
                "Export Successful", 
                f"Results exported successfully to:\n\n{files_text}"
            )
            
            self.accept()
            
        except Exception as e:
            QMessageBox.critical(self, "Export Error", f"Failed to export results:\n{str(e)}")
    
    def _export_to_format(self, 
                         results: List[SearchResult], 
                         output_path: str, 
                         format_type: str,
                         options: Dict[str, bool]):
        """Export results to specific format"""
        if format_type == "csv":
            with open(output_path, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                
                header = ["Rank", "Folder", "Image", "FrameID", "Similarity", "File_Path"]
                if options["include_metadata"]:
                    header.extend(["Scene_Tags", "Detected_Objects"])
                writer.writerow(header)
                
                for result in results:
                    row = [
                        result.rank,
                        result.metadata.folder_name,
                        result.metadata.image_name,
                        result.metadata.frame_id,
                        f"{result.similarity_score:.4f}",
                        result.metadata.file_path
                    ]
                    
                    if options["include_metadata"]:
                        row.extend([
                            "; ".join(getattr(result.metadata, 'scene_tags', []) or []),
                            "; ".join(getattr(result.metadata, 'detected_objects', []) or [])
                        ])
                    
                    writer.writerow(row)
        
        elif format_type == "json":
            export_data = {
                "export_timestamp": time.time(),
                "total_results": len(results),
                "options": options,
                "results": []
            }
            
            for result in results:
                result_data = {
                    "rank": result.rank,
                    "similarity_score": result.similarity_score,
                    "folder_name": result.metadata.folder_name,
                    "image_name": result.metadata.image_name,
                    "frame_id": result.metadata.frame_id,
                    "file_path": result.metadata.file_path
                }
                
                if options["include_metadata"]:
                    result_data.update({
                        "scene_tags": getattr(result.metadata, 'scene_tags', []) or [],
                        "detected_objects": getattr(result.metadata, 'detected_objects', []) or []
                    })
                
                export_data["results"].append(result_data)
            
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(export_data, f, indent=2, ensure_ascii=False)


class RemoteBrowserDialog(QDialog):
    """Dialog for browsing remote server files and folders"""
    
    def __init__(self, network_client, host, port, hostname, parent=None):
        super().__init__(parent)
        self.network_client = network_client
        self.host = host
        self.port = port
        self.hostname = hostname
        
        self.setWindowTitle(f"Remote Browser - {hostname} ({host}:{port})")
        self.setMinimumSize(800, 600)
        
        self._setup_ui()
        self._load_folders()
    
    def _setup_ui(self):
        """Setup dialog UI"""
        layout = QVBoxLayout(self)
        
        # Header
        header_label = QLabel(f" Browsing: {self.hostname} ({self.host}:{self.port})")
        header_label.setStyleSheet("font-weight: bold; font-size: 14px; padding: 10px;")
        layout.addWidget(header_label)
        
        # Splitter for folders and files
        splitter = QSplitter(Qt.Horizontal)
        
        # Folders panel
        folders_widget = QWidget()
        folders_layout = QVBoxLayout(folders_widget)
        
        folders_label = QLabel(" Shared Folders")
        folders_label.setStyleSheet("font-weight: bold;")
        folders_layout.addWidget(folders_label)
        
        self.folders_list = QTableWidget()
        self.folders_list.setColumnCount(2)
        self.folders_list.setHorizontalHeaderLabels(["Name", "Path"])
        self.folders_list.horizontalHeader().setStretchLastSection(True)
        self.folders_list.setSelectionBehavior(QTableWidget.SelectRows)
        self.folders_list.itemSelectionChanged.connect(self._on_folder_selected)
        folders_layout.addWidget(self.folders_list)
        
        splitter.addWidget(folders_widget)
        
        # Files panel
        files_widget = QWidget()
        files_layout = QVBoxLayout(files_widget)
        
        self.files_label = QLabel(" Files (Select a folder)")
        self.files_label.setStyleSheet("font-weight: bold;")
        files_layout.addWidget(self.files_label)
        
        self.files_list = QTableWidget()
        self.files_list.setColumnCount(4)
        self.files_list.setHorizontalHeaderLabels(["Name", "Size", "Type", "Modified"])
        self.files_list.horizontalHeader().setStretchLastSection(True)
        self.files_list.setSelectionBehavior(QTableWidget.SelectRows)
        self.files_list.itemDoubleClicked.connect(self._on_file_double_click)
        files_layout.addWidget(self.files_list)
        
        # File actions
        file_actions = QHBoxLayout()
        
        self.view_file_btn = QPushButton(" View File")
        self.download_file_btn = QPushButton(" Download")
        self.search_files_btn = QPushButton(" Search in Files")
        
        self.view_file_btn.clicked.connect(self._view_selected_file)
        self.download_file_btn.clicked.connect(self._download_selected_file)
        self.search_files_btn.clicked.connect(self._search_in_files)
        
        self.view_file_btn.setEnabled(False)
        self.download_file_btn.setEnabled(False)
        
        file_actions.addWidget(self.view_file_btn)
        file_actions.addWidget(self.download_file_btn)
        file_actions.addWidget(self.search_files_btn)
        file_actions.addStretch()
        
        files_layout.addLayout(file_actions)
        
        splitter.addWidget(files_widget)
        
        # Enable file action buttons when file is selected
        self.files_list.itemSelectionChanged.connect(self._on_file_selected)
        
        layout.addWidget(splitter)
        
        # Dialog buttons
        button_layout = QHBoxLayout()
        
        refresh_btn = QPushButton(" Refresh")
        close_btn = QPushButton("Close")
        
        refresh_btn.clicked.connect(self._load_folders)
        close_btn.clicked.connect(self.accept)
        
        button_layout.addStretch()
        button_layout.addWidget(refresh_btn)
        button_layout.addWidget(close_btn)
        
        layout.addLayout(button_layout)
    
    def _load_folders(self):
        """Load shared folders from remote server"""
        try:
            folders = self.network_client.get_shared_folders(self.host, self.port)
            
            self.folders_list.setRowCount(len(folders))
            
            for i, folder in enumerate(folders):
                name_item = QTableWidgetItem(folder.get('name', 'Unknown'))
                path_item = QTableWidgetItem(folder.get('path', 'Unknown'))
                
                self.folders_list.setItem(i, 0, name_item)
                self.folders_list.setItem(i, 1, path_item)
                
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Failed to load folders: {str(e)}")
    
    def _on_folder_selected(self):
        """Handle folder selection"""
        current_row = self.folders_list.currentRow()
        if current_row >= 0:
            folder_name = self.folders_list.item(current_row, 0).text()
            self.files_label.setText(f" Files in: {folder_name}")
            self._load_files(folder_name)
    
    def _load_files(self, folder_name):
        """Load files from selected folder"""
        try:
            # Need to implement get_folder_files in NetworkClient
            # For now, show placeholder
            self.files_list.setRowCount(1)
            placeholder_item = QTableWidgetItem("Loading files...")
            self.files_list.setItem(0, 0, placeholder_item)
            self.files_list.setItem(0, 1, QTableWidgetItem(""))
            self.files_list.setItem(0, 2, QTableWidgetItem(""))
            self.files_list.setItem(0, 3, QTableWidgetItem(""))
            
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Failed to load files: {str(e)}")
    
    def _on_file_selected(self):
        """Handle file selection"""
        has_selection = len(self.files_list.selectedItems()) > 0
        self.view_file_btn.setEnabled(has_selection)
        self.download_file_btn.setEnabled(has_selection)
    
    def _on_file_double_click(self, item):
        """Handle file double click"""
        self._view_selected_file()
    
    def _view_selected_file(self):
        """View selected file"""
        current_row = self.files_list.currentRow()
        if current_row >= 0:
            file_name = self.files_list.item(current_row, 0).text()
            QMessageBox.information(self, "View File", f"Viewing: {file_name}\n\n(View functionality to be implemented)")
    
    def _download_selected_file(self):
        """Download selected file"""
        current_row = self.files_list.currentRow()
        if current_row >= 0:
            file_name = self.files_list.item(current_row, 0).text()
            QMessageBox.information(self, "Download File", f"Downloading: {file_name}\n\n(Download functionality to be implemented)")
    
    def _search_in_files(self):
        """Search in remote files"""
        text, ok = QInputDialog.getText(self, "Search Files", "Enter search term:")
        if ok and text:
            QMessageBox.information(self, "Search", f"Searching for: {text}\n\n(Search functionality to be implemented)")


# ================================================================================
# MAIN WINDOW
# ================================================================================



class MainWindow(QMainWindow):
    """Enhanced Main Application Window - Modern main window with advanced features"""
    
    def __init__(self, retrieval_system: Optional[EnhancedRetrievalSystem] = None):
        """Initialize main window"""
        super().__init__()
        
        # System initialization
        self.system = retrieval_system
        self.logger = None
        self.config = None
        
        # PATCH: Store system reference globally for recovery
        if retrieval_system:
            app = QApplication.instance()
            if app:
                app.retrieval_system = retrieval_system
        
        # Initialize logger and config
        if retrieval_system:
            self.logger = retrieval_system.logger
            self.config = retrieval_system.config
        else:
            try:
                self.logger = Logger()
                self.config = Config()
            except:
                import logging
                self.logger = logging.getLogger(__name__)
                self.config = None
        
        # Initialize machine name from config
        self.machine_name = None
        if self.config and hasattr(self.config, 'network') and isinstance(self.config.network, dict):
            self.machine_name = self.config.network.get('machine_name')
        elif self.config and hasattr(self.config, 'config') and isinstance(self.config.config, dict):
            network_config = self.config.config.get('network', {})
            self.machine_name = network_config.get('machine_name')
        
        # Add unified index support to system (after logger is available)
        if self.system:
            try:
                from unified_builder import add_unified_index_support
                add_unified_index_support(self.system)
            except Exception as e:
                if self.logger:
                    self.logger.warning(f"Could not initialize unified index support: {e}")
                else:
                    print(f"Could not initialize unified index support: {e}")
        
        # UI state
        self.current_results = []
        self.worker_threads = []
        
        # Track displayed and exported results
        self.displayed_results = set()
        self.exported_results = set()
        
        # Apply theme
        self.theme = UITheme()
        self.setStyleSheet(self.theme.get_stylesheet())
        
        # Setup UI
        self._setup_ui()
        self._setup_menu_bar()
        self._setup_status_bar()
        
        # Window properties
        self.setWindowTitle("Enhanced Retrieval System v2.1")
        
        # Set window icon from logo file
        self._set_window_icon()
        
        original_width = 1670
        original_height = 850
        
        screen = QApplication.primaryScreen()
        if screen:
            screen_geometry = screen.geometry()
            screen_width = screen_geometry.width()
            screen_height = screen_geometry.height()
            
            if original_width > screen_width:
                original_width = int(screen_width * 0.95)
            if original_height > screen_height:
                original_height = int(screen_height * 0.9)
        
        self.resize(original_width, original_height)
        self.setMinimumSize(800, 600)
        
        # Initialize system if not provided
        if not self.system:
            self._initialize_system()
        
        if self.logger:
            self.logger.info("Main window initialized")
    
    def _setup_ui(self):
        """Setup main user interface"""
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(5, 5, 5, 5)
        main_layout.setSpacing(5)
        
        # Top section - Search interface
        search_section = self._create_search_section()
        
        # Middle section - Tabs for different views
        self.tab_widget = QTabWidget()
        self.tab_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        
        
        # Results tab
        self.results_widget = ResultDisplayWidget(system=self.system)
        self.results_widget.selection_changed.connect(self._on_selection_changed)
        self.tab_widget.addTab(self.results_widget, " Search Results")
        
        # Chat tab
        if self.system:
            self.chat_widget = ChatInterface(self.system)
            self.chat_widget.search_requested.connect(self._perform_search)
            self.chat_widget.frame_selected.connect(self._on_chat_frame_selected)
            self.tab_widget.addTab(self.chat_widget, " Chat Interface")
        
        # System info tab
        self.system_info_widget = self._create_system_info_widget()
        self.tab_widget.addTab(self.system_info_widget, " System Info")
        
        # Network tab
        self.network_widget = self._create_network_widget()
        self.tab_widget.addTab(self.network_widget, " Network")
        
        # Bottom section - Progress tracking
        self.progress_manager = ProgressManager()
        
        # Add to main layout
        main_layout.addWidget(search_section)
        main_layout.addWidget(self.tab_widget, 1)
        main_layout.addWidget(self.progress_manager)
    
    def _create_search_section(self) -> QWidget:
        """Create search interface section"""
        section = QGroupBox(" Search Interface")
        layout = QVBoxLayout(section)
        
        # Search input row
        search_row = QHBoxLayout()
        
        self.search_input = QTextEdit()
        self.search_input.setMaximumHeight(80)
        self.search_input.setPlaceholderText("Enter your search query here... (supports multiple languages)\nPress Enter to search, Shift+Enter for new line")
        
        # Add Enter key support for search
        self.search_input.installEventFilter(self)
        
        self.search_button = QPushButton("Search")
        self.search_button.setMinimumSize(100, 60)
        self.search_button.clicked.connect(self._on_search_clicked)
        
        search_row.addWidget(self.search_input, 1)
        search_row.addWidget(self.search_button)
        
        # Options row
        options_row = QHBoxLayout()
        
        # Search mode
        options_row.addWidget(QLabel("Mode:"))
        self.mode_combo = QComboBox()
        self.mode_combo.addItems(["hybrid", "clip_only", "llm_enhanced"])
        self.mode_combo.setCurrentText("hybrid")
        options_row.addWidget(self.mode_combo)
        
        # Result limit
        options_row.addWidget(QLabel("Limit:"))
        self.limit_spinbox = QSpinBox()
        self.limit_spinbox.setRange(1, 200)
        self.limit_spinbox.setValue(50)
        options_row.addWidget(self.limit_spinbox)
        
        # Additional options
        self.temporal_checkbox = QCheckBox("Include temporal context")
        self.temporal_checkbox.setChecked(True)
        options_row.addWidget(self.temporal_checkbox)
        
        self.explanations_checkbox = QCheckBox("Include explanations")
        options_row.addWidget(self.explanations_checkbox)
        
        self.hide_displayed_checkbox = QCheckBox("Hide Result displayed")
        self.hide_displayed_checkbox.setChecked(False)
        self.hide_displayed_checkbox.setToolTip("Hide previously queried or exported results from new searches")
        options_row.addWidget(self.hide_displayed_checkbox)
        
        # Clear tracked results button
        self.clear_tracked_btn = QPushButton("Clear")
        self.clear_tracked_btn.setMaximumSize(70, 30)
        self.clear_tracked_btn.setToolTip("Clear tracked displayed and exported results")
        self.clear_tracked_btn.clicked.connect(self._clear_tracked_results)
        options_row.addWidget(self.clear_tracked_btn)
        
        options_row.addStretch()
        
        # Translation info display
        self.translation_info = QLabel("")
        self.translation_info.setStyleSheet("""
            QLabel {
                background-color: #FFF3E0;
                color: #d67302;
                border: 1px solid #FFB74D;
                border-radius: 4px;
                padding: 4px 8px;
                font-size: 11px;
            }
        """)
        self.translation_info.setVisible(False)
        
        # Quick search buttons
        quick_searches = [
            "people talking",
            "cars and vehicles", 
            "outdoor scenes",
            "indoor meeting"
        ]
        
        for query in quick_searches:
            btn = QPushButton(f'"{query}"')
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #FFF3E0;
                    color: #d67302;
                    border: 1px solid #FFB74D;
                    border-radius: 15px;
                    padding: 5px 10px;
                    font-size: 11px;
                }
                QPushButton:hover {
                    background-color: #FFE0B2;
                }
            """)
            btn.clicked.connect(partial(self._quick_search, query))
            options_row.addWidget(btn)
        
        layout.addLayout(search_row)
        layout.addLayout(options_row)
        layout.addWidget(self.translation_info)
        
        return section
    
    def _create_system_info_widget(self) -> QWidget:
        """Create system information widget"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        # System status
        status_group = QGroupBox("System Status")
        status_layout = QFormLayout(status_group)
        
        self.system_status_label = QLabel("Not initialized")
        self.index_status_label = QLabel("No index loaded")
        self.performance_label = QLabel("No data")
        
        status_layout.addRow("System Status:", self.system_status_label)
        status_layout.addRow("Index Status:", self.index_status_label)
        status_layout.addRow("Performance:", self.performance_label)
        
        # System actions
        actions_group = QGroupBox("System Actions")
        actions_layout = QVBoxLayout(actions_group)
        
        action_buttons_layout = QHBoxLayout()
        
        # Core system buttons
        self.build_button = QPushButton(" Build System")
        self.smart_load_button = QPushButton(" Smart Load")
        
        # Advanced buttons
        self.filter_button = QPushButton("Filter Frames")
        self.optimize_button = QPushButton("Optimize Index")
        self.cleanup_button = QPushButton("Cleanup")
        
        # Connect main buttons
        self.build_button.clicked.connect(self._smart_build_system)
        self.smart_load_button.clicked.connect(self._smart_load_system)
        
        # Connect advanced buttons
        self.filter_button.clicked.connect(self._filter_frames)
        self.optimize_button.clicked.connect(self._optimize_system)
        self.cleanup_button.clicked.connect(self._cleanup_system)
        
        # Set button styles and tooltips
        self.build_button.setStyleSheet("QPushButton { background-color: #2E8B57; color: white; font-weight: bold; padding: 8px; }")
        self.smart_load_button.setStyleSheet("QPushButton { background-color: #4682B4; color: white; font-weight: bold; padding: 8px; }")
        
        self.build_button.setToolTip("Build system from keyframes (auto-creates portable package)")
        self.smart_load_button.setToolTip("Smart load: auto-detects index type (legacy or portable)")
        
        # Main action buttons
        action_buttons_layout.addWidget(self.build_button)
        action_buttons_layout.addWidget(self.smart_load_button)
        
        # Advanced buttons
        advanced_layout = QHBoxLayout()
        self.filter_button.setMaximumHeight(30)
        self.optimize_button.setMaximumHeight(30) 
        self.cleanup_button.setMaximumHeight(30)
        
        advanced_layout.addWidget(self.filter_button)
        advanced_layout.addWidget(self.optimize_button)
        advanced_layout.addWidget(self.cleanup_button)
        
        actions_layout.addLayout(action_buttons_layout)
        actions_layout.addLayout(advanced_layout)
        
        # Statistics table
        stats_group = QGroupBox("System Statistics")
        stats_layout = QVBoxLayout(stats_group)
        
        self.stats_table = QTableWidget()
        self.stats_table.setColumnCount(2)
        self.stats_table.setHorizontalHeaderLabels(["Metric", "Value"])
        self.stats_table.horizontalHeader().setStretchLastSection(True)
        
        stats_layout.addWidget(self.stats_table)
        
        # Refresh button
        refresh_button = QPushButton("Refresh Statistics")
        refresh_button.clicked.connect(self._refresh_stats)
        stats_layout.addWidget(refresh_button)
        
        layout.addWidget(status_group)
        layout.addWidget(actions_group)
        layout.addWidget(stats_group)
        layout.addStretch()
        
        # Initial update
        self._update_system_info()
        
        return widget
    
    def _create_network_widget(self) -> QWidget:
        """Create distributed network management widget"""
        widget = QWidget()
        main_layout = QHBoxLayout(widget)
        main_layout.setSpacing(15)
        
        # Left column
        left_column = QVBoxLayout()
        left_column.setSpacing(10)
        
        # Right column  
        right_column = QVBoxLayout()
        right_column.setSpacing(10)
        
        # Machine identity section
        identity_group = QGroupBox(" Machine Identity")
        identity_layout = QVBoxLayout(identity_group)
        
        # Machine name input
        name_layout = QHBoxLayout()
        name_layout.addWidget(QLabel("Machine Name:"))
        self.machine_name_input = QLineEdit()
        self.machine_name_input.setPlaceholderText("Enter your machine name (e.g., 'John's PC', 'Lab Computer 1')")
        
        # Get saved machine name or default from computer name
        import socket
        if self.machine_name:
            self.machine_name_input.setText(self.machine_name)
        else:
            default_name = socket.gethostname()
            self.machine_name_input.setText(default_name)
        
        save_name_btn = QPushButton(" Save Name")
        save_name_btn.clicked.connect(self._save_machine_name)
        
        name_layout.addWidget(self.machine_name_input, 1)
        name_layout.addWidget(save_name_btn)
        
        identity_layout.addLayout(name_layout)
        
        # Network server section
        server_group = QGroupBox(" Network Server")
        server_layout = QVBoxLayout(server_group)
        
        # Server controls
        server_controls = QHBoxLayout()
        
        self.start_server_btn = QPushButton(" Start Server")
        self.stop_server_btn = QPushButton(" Stop Server")
        self.server_status_label = QLabel(" Server Stopped")
        
        self.start_server_btn.setStyleSheet("QPushButton { background-color: #2E8B57; color: white; font-weight: bold; padding: 8px; }")
        self.stop_server_btn.setStyleSheet("QPushButton { background-color: #DC143C; color: white; font-weight: bold; padding: 8px; }")
        self.stop_server_btn.setEnabled(False)
        
        self.start_server_btn.clicked.connect(self._start_network_server)
        self.stop_server_btn.clicked.connect(self._stop_network_server)
        
        server_controls.addWidget(self.start_server_btn)
        server_controls.addWidget(self.stop_server_btn)
        server_controls.addWidget(self.server_status_label)
        server_controls.addStretch()
        
        # Server configuration
        server_config = QHBoxLayout()
        server_config.addWidget(QLabel("Port:"))
        self.server_port_spin = QSpinBox()
        self.server_port_spin.setRange(1024, 65535)
        self.server_port_spin.setValue(5000)
        server_config.addWidget(self.server_port_spin)
        server_config.addStretch()
        
        server_layout.addLayout(server_controls)
        server_layout.addLayout(server_config)
        
        # Shared resources section  
        shared_group = QGroupBox(" Shared Resources")
        shared_layout = QVBoxLayout(shared_group)
        
        # Shared folders
        shared_folders_layout = QHBoxLayout()
        shared_folders_layout.addWidget(QLabel("Folders:"))
        
        self.add_folder_btn = QPushButton(" Add Folder")
        self.remove_folder_btn = QPushButton(" Remove")
        self.shared_folders_list = QTableWidget()
        self.shared_folders_list.setColumnCount(3)
        self.shared_folders_list.setHorizontalHeaderLabels(["Name", "Path", "Files"])
        self.shared_folders_list.horizontalHeader().setStretchLastSection(True)
        self.shared_folders_list.setMaximumHeight(120)
        
        self.add_folder_btn.clicked.connect(self._add_shared_folder)
        self.remove_folder_btn.clicked.connect(self._remove_shared_folder)
        
        shared_folders_layout.addWidget(self.add_folder_btn)
        shared_folders_layout.addWidget(self.remove_folder_btn)
        shared_folders_layout.addStretch()
        
        # Shared indexes
        shared_indexes_layout = QHBoxLayout()
        shared_indexes_layout.addWidget(QLabel("Indexes:"))
        
        self.add_index_btn = QPushButton(" Add Index")
        self.remove_index_btn = QPushButton(" Remove")
        self.shared_indexes_list = QTableWidget()
        self.shared_indexes_list.setColumnCount(3)
        self.shared_indexes_list.setHorizontalHeaderLabels(["Name", "Path", "Size"])
        self.shared_indexes_list.horizontalHeader().setStretchLastSection(True)
        self.shared_indexes_list.setMaximumHeight(120)
        
        self.add_index_btn.clicked.connect(self._add_shared_index)
        self.remove_index_btn.clicked.connect(self._remove_shared_index)
        
        shared_indexes_layout.addWidget(self.add_index_btn)
        shared_indexes_layout.addWidget(self.remove_index_btn)
        shared_indexes_layout.addStretch()
        
        shared_layout.addLayout(shared_folders_layout)
        shared_layout.addWidget(self.shared_folders_list)
        shared_layout.addLayout(shared_indexes_layout)
        shared_layout.addWidget(self.shared_indexes_list)
        
        # Network discovery section
        discovery_group = QGroupBox(" Network Discovery")
        discovery_layout = QVBoxLayout(discovery_group)
        
        # Discovery controls
        discovery_controls = QHBoxLayout()
        
        self.discover_btn = QPushButton(" Discover Networks")
        self.refresh_nodes_btn = QPushButton(" Refresh")
        self.connect_selected_btn = QPushButton(" Connect to Selected")
        
        self.discover_btn.clicked.connect(self._discover_networks)
        self.refresh_nodes_btn.clicked.connect(self._refresh_discovered_nodes)
        self.connect_selected_btn.clicked.connect(self._connect_to_selected)
        
        discovery_controls.addWidget(self.discover_btn)
        discovery_controls.addWidget(self.refresh_nodes_btn)
        discovery_controls.addWidget(self.connect_selected_btn)
        discovery_controls.addStretch()
        
        # Manual connection section
        manual_connect_layout = QHBoxLayout()
        manual_connect_layout.addWidget(QLabel("Manual Connect:"))
        
        self.manual_host_input = QLineEdit()
        self.manual_host_input.setPlaceholderText("IP Address (e.g., 192.168.1.100)")
        self.manual_host_input.setMinimumWidth(200)
        
        self.manual_port_input = QSpinBox()
        self.manual_port_input.setRange(1024, 65535)
        self.manual_port_input.setValue(8000)
        self.manual_port_input.setMinimumWidth(80)
        
        self.connect_manual_btn = QPushButton(" Connect")
        self.connect_manual_btn.clicked.connect(self._manual_connect)
        
        manual_connect_layout.addWidget(self.manual_host_input)
        manual_connect_layout.addWidget(QLabel(":"))
        manual_connect_layout.addWidget(self.manual_port_input)
        manual_connect_layout.addWidget(self.connect_manual_btn)
        manual_connect_layout.addStretch()
        
        # Discovered nodes table
        self.discovered_nodes_table = QTableWidget()
        self.discovered_nodes_table.setColumnCount(4)
        self.discovered_nodes_table.setHorizontalHeaderLabels(["Machine Name", "IP Address", "Port", "Status"])
        self.discovered_nodes_table.horizontalHeader().setStretchLastSection(True)
        self.discovered_nodes_table.setMaximumHeight(150)
        
        discovery_layout.addLayout(discovery_controls)
        discovery_layout.addLayout(manual_connect_layout)
        discovery_layout.addWidget(self.discovered_nodes_table)
        
        # Connected servers section
        connected_group = QGroupBox(" Connected Servers")
        connected_layout = QVBoxLayout(connected_group)
        
        # Connection controls
        connection_controls = QHBoxLayout()
        
        self.browse_remote_btn = QPushButton(" Browse Remote")
        self.upload_files_btn = QPushButton(" Upload Files")
        self.remote_search_btn = QPushButton(" Remote Search")
        self.load_remote_index_btn = QPushButton(" Load Remote Index")
        self.disconnect_btn = QPushButton(" Disconnect")
        
        self.browse_remote_btn.clicked.connect(self._browse_remote_server)
        self.upload_files_btn.clicked.connect(self._upload_files_to_selected_server)
        self.remote_search_btn.clicked.connect(self._remote_search)
        self.load_remote_index_btn.clicked.connect(self._load_remote_index)
        self.disconnect_btn.clicked.connect(self._disconnect_server)
        
        connection_controls.addWidget(self.browse_remote_btn)
        connection_controls.addWidget(self.upload_files_btn)
        connection_controls.addWidget(self.remote_search_btn)
        connection_controls.addWidget(self.load_remote_index_btn)
        connection_controls.addWidget(self.disconnect_btn)
        connection_controls.addStretch()
        
        # Connected servers table
        self.connected_servers_table = QTableWidget()
        self.connected_servers_table.setColumnCount(4)
        self.connected_servers_table.setHorizontalHeaderLabels(["Hostname", "IP Address", "Connected", "Status"])
        self.connected_servers_table.horizontalHeader().setStretchLastSection(True)
        self.connected_servers_table.setMaximumHeight(120)
        
        connected_layout.addLayout(connection_controls)
        connected_layout.addWidget(self.connected_servers_table)
        
        # Add sections to columns
        # Left column: Identity, Server and Shared Resources  
        left_column.addWidget(identity_group)
        left_column.addWidget(server_group)
        left_column.addWidget(shared_group)
        left_column.addStretch()
        
        # Right column: Discovery and Connected Servers
        right_column.addWidget(discovery_group)
        right_column.addWidget(connected_group)
        right_column.addStretch()
        
        # Add columns to main layout
        main_layout.addLayout(left_column)
        main_layout.addLayout(right_column)
        
        # Initialize network components
        self.network_server = None
        self.network_client = None
        self._initialize_network_components()
        
        return widget
    
    def _initialize_network_components(self):
        """Initialize network components"""
        try:
            # Import network classes from api.py
            from api import NetworkServer, NetworkClient, NetworkDiscovery
            
            # Create network client for connections
            self.network_client = NetworkClient(logger=self.logger)
            
            # Initialize discovery
            self.network_discovery = NetworkDiscovery(logger=self.logger)
            
            if self.logger:
                self.logger.info(" Network components initialized")
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to initialize network components: {e}")
    
    def _start_network_server(self):
        """Start network server"""
        try:
            if self.network_server and self.network_server.is_running:
                self.logger.warning("Network server is already running")
                return
            
            # Get port from GUI
            port = self.server_port_spin.value()
            
            # Import and create server
            from api import NetworkServer
            self.network_server = NetworkServer(port=port, logger=self.logger)
            
            # Start server and validate it actually started
            server_started = self.network_server.start_server()
            
            if not server_started:
                raise Exception("Failed to start HTTP server - port may be in use")
            
            # Wait a moment and verify server is actually running
            import time
            time.sleep(1)
            
            # Validate server is actually listening
            import requests
            try:
                response = requests.get(f"http://localhost:{port}/api/ping", timeout=3)
                if response.status_code != 200:
                    raise Exception(f"Server not responding correctly (HTTP {response.status_code})")
            except requests.exceptions.ConnectionError:
                self.network_server.stop_server()
                raise Exception("Server failed to start - no HTTP listener active")
            except requests.exceptions.Timeout:
                self.network_server.stop_server()
                raise Exception("Server not responding - startup timeout")
            
            # Start network discovery service
            if hasattr(self, 'network_discovery') and self.network_discovery:
                try:
                    self.network_discovery.start_discovery()
                    if self.logger:
                        self.logger.info(" Network discovery service started")
                except Exception as e:
                    if self.logger:
                        self.logger.warning(f"Failed to start discovery service: {e}")
            
            # Only update GUI after confirming server is actually running
            self.start_server_btn.setText(" Stop Server")
            self.start_server_btn.clicked.disconnect()
            self.start_server_btn.clicked.connect(self._stop_network_server)
            
            # Update status
            self.server_status_label.setText(" Server Running")
            self.server_status_label.setStyleSheet("color: green; font-weight: bold;")
            
            if self.logger:
                self.logger.info(f" Network server validated and running on port {port}")
                
        except Exception as e:
            # Clean up on failure
            if hasattr(self, 'network_server') and self.network_server:
                try:
                    self.network_server.stop_server()
                except:
                    pass
                self.network_server = None
                    
            # Update GUI to show failed state
            self.start_server_btn.setText(" Start Server")
            try:
                self.start_server_btn.clicked.disconnect()
            except:
                pass
            self.start_server_btn.clicked.connect(self._start_network_server)
            
            self.server_status_label.setText(" Server Failed")
            self.server_status_label.setStyleSheet("color: red; font-weight: bold;")
            
            if self.logger:
                self.logger.error(f"Failed to start network server: {e}")
            self.show_error("Server Error", f"Failed to start server: {str(e)}")
    
    def _stop_network_server(self):
        """Stop network server"""
        try:
            # Stop discovery service first
            if hasattr(self, 'network_discovery') and self.network_discovery:
                try:
                    self.network_discovery.stop_discovery()
                    if self.logger:
                        self.logger.info(" Network discovery service stopped")
                except Exception as e:
                    if self.logger:
                        self.logger.warning(f"Failed to stop discovery service: {e}")
            
            # Stop network server
            if self.network_server:
                try:
                    self.network_server.stop()
                    if self.logger:
                        self.logger.info(" Network server stopped successfully")
                except Exception as e:
                    if self.logger:
                        self.logger.warning(f"Error stopping server: {e}")
                finally:
                    self.network_server = None
            
            # Update GUI - always update even if stop failed
            self.start_server_btn.setText(" Start Server")
            try:
                self.start_server_btn.clicked.disconnect()
            except:
                pass  # Ignore if no connections to disconnect
            self.start_server_btn.clicked.connect(self._start_network_server)
            
            # Update status
            self.server_status_label.setText(" Server Stopped")
            self.server_status_label.setStyleSheet("color: red; font-weight: bold;")
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to stop network server: {e}")
    
    def _check_server_status(self):
        """Check if server is actually running and update GUI accordingly"""
        try:
            if not self.network_server:
                return False
                
            # Check if server claims to be running
            if not (self.network_server.is_running and self.network_server.server_active):
                return False
            
            # Validate with HTTP request
            port = self.server_port_spin.value()
            import requests
            try:
                response = requests.get(f"http://localhost:{port}/api/ping", timeout=2)
                return response.status_code == 200
            except:
                return False
                
        except Exception as e:
            if self.logger:
                self.logger.warning(f"Server status check failed: {e}")
            return False
    
    def _save_machine_name(self):
        """Save machine name to config"""
        try:
            machine_name = self.machine_name_input.text().strip()
            if not machine_name:
                QMessageBox.warning(self, "Warning", "Please enter a machine name!")
                return
            
            # Update instance attribute
            self.machine_name = machine_name
            
            # Save to config safely
            if self.config:
                # Handle different config structures
                if hasattr(self.config, 'config') and isinstance(self.config.config, dict):
                    # Config class with .config attribute
                    if 'network' not in self.config.config:
                        self.config.config['network'] = {}
                    self.config.config['network']['machine_name'] = machine_name
                elif hasattr(self.config, 'network'):
                    # Direct config object with network attribute
                    if isinstance(self.config.network, dict):
                        self.config.network['machine_name'] = machine_name
                    else:
                        self.config.network = {'machine_name': machine_name}
                else:
                    # Fallback: try to add network attribute
                    try:
                        self.config.network = {'machine_name': machine_name}
                    except:
                        if self.logger:
                            self.logger.warning("Could not save machine name to config - config object is readonly")
                
                # Save config to file
                self._save_config()
                
            # Update network server if running
            if self.network_server:
                self.network_server.machine_name = machine_name
                
            QMessageBox.information(self, "Success", f"Machine name saved: {machine_name}")
            
            if self.logger:
                self.logger.info(f"Machine name saved: {machine_name}")
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to save machine name: {e}")
            QMessageBox.critical(self, "Error", f"Failed to save machine name: {e}")
    
    def _handle_file_upload(self, file_paths):
        """Handle uploaded files from drag & drop"""
        try:
            if not file_paths:
                return
                
            # Show progress
            self.upload_progress.setVisible(True)
            self.upload_progress.setValue(0)
            
            uploaded_count = 0
            total_files = len(file_paths)
            
            # Get target shared folder
            target_folder = self._get_default_shared_folder()
            if not target_folder:
                QMessageBox.warning(self, "Warning", "No shared folder configured. Please add a shared folder first.")
                self.upload_progress.setVisible(False)
                return
            
            for i, file_path in enumerate(file_paths):
                try:
                    # Copy file to shared folder
                    import shutil
                    target_path = os.path.join(target_folder, os.path.basename(file_path))
                    
                    # Handle duplicate filenames
                    counter = 1
                    original_target = target_path
                    while os.path.exists(target_path):
                        name, ext = os.path.splitext(original_target)
                        target_path = f"{name}_{counter}{ext}"
                        counter += 1
                    
                    shutil.copy2(file_path, target_path)
                    uploaded_count += 1
                    
                    # Update progress
                    progress = int((i + 1) * 100 / total_files)
                    self.upload_progress.setValue(progress)
                    
                    if self.logger:
                        self.logger.info(f"Uploaded file: {os.path.basename(file_path)} -> {target_path}")
                        
                except Exception as file_error:
                    if self.logger:
                        self.logger.error(f"Failed to upload {file_path}: {file_error}")
            
            # Hide progress and show result
            self.upload_progress.setVisible(False)
            
            if uploaded_count > 0:
                QMessageBox.information(
                    self, "Upload Complete", 
                    f"Successfully uploaded {uploaded_count}/{total_files} files to shared folder."
                )
                
                # Refresh shared folders display
                self._refresh_shared_folders()
            else:
                QMessageBox.warning(self, "Upload Failed", "No files were uploaded successfully.")
                
        except Exception as e:
            self.upload_progress.setVisible(False)
            if self.logger:
                self.logger.error(f"File upload error: {e}")
            QMessageBox.critical(self, "Error", f"Upload failed: {e}")
    
    def _browse_files_upload(self):
        """Browse and select files for upload"""
        try:
            file_paths, _ = QFileDialog.getOpenFileNames(
                self, 
                "Select Files to Upload",
                "",
                "All Files (*.*);;"
                "Images (*.jpg *.jpeg *.png *.bmp *.gif);;"
                "Videos (*.mp4 *.avi *.mkv *.mov *.wmv);;"
                "Documents (*.pdf *.doc *.docx *.txt);;"
                "Archives (*.zip *.rar *.7z)"
            )
            
            if file_paths:
                self._handle_file_upload(file_paths)
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"File browse error: {e}")
            QMessageBox.critical(self, "Error", f"Failed to browse files: {e}")
    
    def _get_default_shared_folder(self):
        """Get the default shared folder path"""
        try:
            # Return first shared folder if any
            if self.shared_folders_list.rowCount() > 0:
                return self.shared_folders_list.item(0, 1).text()  # Path column
            return None
        except:
            return None
    
    def _refresh_shared_folders(self):
        """Refresh shared folders display"""
        try:
            if self.network_server:
                # Update file counts in table
                for row in range(self.shared_folders_list.rowCount()):
                    folder_path = self.shared_folders_list.item(row, 1).text()
                    if os.path.exists(folder_path):
                        file_count = len([f for f in os.listdir(folder_path) 
                                        if os.path.isfile(os.path.join(folder_path, f))])
                        self.shared_folders_list.setItem(row, 2, QTableWidgetItem(str(file_count)))
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to refresh shared folders: {e}")
    
    def _save_config(self):
        """Save configuration to file"""
        try:
            if self.config and hasattr(self.config, 'save_config'):
                # Use Config class's save_config method if available
                self.config.save_config()
            elif self.config and hasattr(self.config, 'config'):
                # If config has a 'config' attribute, save that
                with open('config.json', 'w', encoding='utf-8') as f:
                    json.dump(self.config.config, f, indent=2, ensure_ascii=False)
            else:
                # Fallback: create simple config dict
                config_data = {
                    "system": {"name": "Enhanced Retrieval System", "version": "2.1"},
                    "gui": {"window_width": 1670, "window_height": 850},
                    "network": {"machine_name": getattr(self, 'machine_name', None)}
                }
                with open('config.json', 'w', encoding='utf-8') as f:
                    json.dump(config_data, f, indent=2, ensure_ascii=False)
                    
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to save config: {e}")
    
    def _add_shared_folder(self):
        """Add shared folder"""
        try:
            folder_path = QFileDialog.getExistingDirectory(self, "Select Folder to Share")
            if not folder_path:
                return
            
            # Add to server if running
            if self.network_server:
                folder_id = self.network_server.add_shared_folder(folder_path)
                
                # Update table
                row = self.shared_folders_list.rowCount()
                self.shared_folders_list.insertRow(row)
                self.shared_folders_list.setItem(row, 0, QTableWidgetItem(folder_id))
                self.shared_folders_list.setItem(row, 1, QTableWidgetItem(folder_path))
                self.shared_folders_list.setItem(row, 2, QTableWidgetItem(" Active"))
                
                if self.logger:
                    self.logger.info(f" Added shared folder: {folder_path}")
            else:
                self.show_error("Server Error", "Server must be running to share folders")
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to add shared folder: {e}")
            self.show_error("Folder Error", f"Failed to add shared folder: {str(e)}")
    
    def _remove_shared_folder(self):
        """Remove selected shared folder"""
        try:
            current_row = self.shared_folders_list.currentRow()
            if current_row < 0:
                return
            
            folder_id = self.shared_folders_list.item(current_row, 0).text()
            
            # Remove from server
            if self.network_server:
                self.network_server.remove_shared_folder(folder_id)
            
            # Remove from table
            self.shared_folders_list.removeRow(current_row)
            
            if self.logger:
                self.logger.info(f" Removed shared folder: {folder_id}")
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to remove shared folder: {e}")
    
    def _add_shared_index(self):
        """Add shared index"""
        try:
            index_file, _ = QFileDialog.getOpenFileName(
                self, "Select Index File to Share", "", "Index Files (*.rvdb)"
            )
            if not index_file:
                return
            
            # Add to server if running
            if self.network_server:
                index_id = self.network_server.add_shared_index(index_file)
                
                # Update table
                row = self.shared_indexes_list.rowCount()
                self.shared_indexes_list.insertRow(row)
                self.shared_indexes_list.setItem(row, 0, QTableWidgetItem(index_id))
                self.shared_indexes_list.setItem(row, 1, QTableWidgetItem(index_file))
                self.shared_indexes_list.setItem(row, 2, QTableWidgetItem(" Active"))
                
                if self.logger:
                    self.logger.info(f" Added shared index: {index_file}")
            else:
                self.show_error("Server Error", "Server must be running to share indexes")
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to add shared index: {e}")
            self.show_error("Index Error", f"Failed to add shared index: {str(e)}")
    
    def _remove_shared_index(self):
        """Remove selected shared index"""
        try:
            current_row = self.shared_indexes_list.currentRow()
            if current_row < 0:
                return
            
            index_id = self.shared_indexes_list.item(current_row, 0).text()
            
            # Remove from server
            if self.network_server:
                self.network_server.remove_shared_index(index_id)
            
            # Remove from table
            self.shared_indexes_list.removeRow(current_row)
            
            if self.logger:
                self.logger.info(f" Removed shared index: {index_id}")
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to remove shared index: {e}")
    
    def _discover_networks(self):
        """Discover networks"""
        try:
            # Prevent multiple concurrent discoveries
            if hasattr(self, '_discovery_in_progress') and self._discovery_in_progress:
                if self.logger:
                    self.logger.warning(" Discovery already in progress, ignoring request")
                return
                
            self._discovery_in_progress = True
            
            if self.logger:
                self.logger.info(" Starting network discovery...")
            
            # Clear previous results
            self.discovered_nodes_table.setRowCount(0)
            
            # Add current machine first
            self._add_current_machine_to_discovery()
            
            # Start periodic refresh
            self._start_periodic_node_refresh()
            
            # Get discovered nodes (discovery service should already be running)
            def discovery_worker():
                import threading
                thread_id = threading.current_thread().ident
                try:
                    if self.logger:
                        self.logger.info(f" Discovery worker {thread_id} started")
                        
                    if hasattr(self, 'network_discovery') and self.network_discovery:
                        # Ensure discovery service is running persistently
                        if not self.network_discovery.discovery_active:
                            self.network_discovery.start_discovery()
                            time.sleep(1.0)  # Wait for service to initialize
                        
                        # Trigger fresh discovery with longer timeout
                        nodes = self.network_discovery.discover_nodes(timeout=15.0)
                    else:
                        nodes = []
                    
                    # Update table on main thread
                    if self.logger:
                        self.logger.info(f" Discovery worker {thread_id} found {len(nodes)} nodes, updating GUI table")
                        for node in nodes:
                            self.logger.info(f"  - Node: {getattr(node, 'hostname', 'Unknown')} ({getattr(node, 'ip_address', 'Unknown')})")
                    
                    # Use proper lambda capture to avoid closure issues
                    if self.logger:
                        self.logger.info(f" Worker {thread_id} scheduling GUI update via QTimer.singleShot for {len(nodes)} nodes")
                    
                    # Store nodes in instance variable for thread-safe access
                    self._discovered_nodes_cache = nodes
                    if self.logger:
                        self.logger.info(f" Worker {thread_id} cached {len(nodes)} nodes for GUI update")
                    
                    # Use QTimer with zero delay for thread-safe GUI update
                    from PyQt5.QtCore import QTimer
                    if self.logger:
                        self.logger.info(f" About to call QTimer.singleShot with _process_cached_nodes")
                    QTimer.singleShot(0, self._process_cached_nodes)
                    if self.logger:
                        self.logger.info(f" QTimer.singleShot called successfully")
                    
                except Exception as e:
                    if self.logger:
                        self.logger.error(f"Discovery worker {thread_id} error: {e}")
                finally:
                    # Mark discovery as complete
                    self._discovery_in_progress = False
                    if self.logger:
                        self.logger.info(f" Discovery worker {thread_id} completed")
            
            import threading
            discovery_thread = threading.Thread(target=discovery_worker, daemon=True)
            discovery_thread.start()
            
        except Exception as e:
            self._discovery_in_progress = False
            if self.logger:
                self.logger.error(f"Failed to start network discovery: {e}")
            self.show_error("Discovery Error", f"Failed to discover networks: {str(e)}")
    
    def _add_current_machine_to_discovery(self):
        """Add current machine to discovery results"""
        try:
            import socket
            import platform
            
            # Get current machine info
            hostname = platform.node() or socket.gethostname()
            machine_name = self.machine_name or hostname
            
            # Try to get local IP
            try:
                # Connect to a remote address to get local IP
                with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                    s.connect(("8.8.8.8", 80))
                    local_ip = s.getsockname()[0]
            except:
                local_ip = "127.0.0.1"
            
            # Get actual server port
            server_port = "5000"  # Default
            if hasattr(self, 'server_port_spin') and self.server_port_spin:
                server_port = str(self.server_port_spin.value())
            elif self.config and hasattr(self.config, 'api') and hasattr(self.config.api, 'port'):
                server_port = str(self.config.api.port)
            elif self.config and hasattr(self.config, 'config') and isinstance(self.config.config, dict):
                api_config = self.config.config.get('api', {})
                server_port = str(api_config.get('port', 5000))
            
            # Add current machine as first row
            row = self.discovered_nodes_table.rowCount()
            self.discovered_nodes_table.insertRow(row)
            
            self.discovered_nodes_table.setItem(row, 0, QTableWidgetItem(f" {machine_name} (This Machine)"))
            self.discovered_nodes_table.setItem(row, 1, QTableWidgetItem(local_ip))
            self.discovered_nodes_table.setItem(row, 2, QTableWidgetItem(server_port))
            self.discovered_nodes_table.setItem(row, 3, QTableWidgetItem(" Local"))
            
            if self.logger:
                self.logger.info(f" Added current machine: {machine_name} ({local_ip})")
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to add current machine to discovery: {e}")
    
    def _process_cached_nodes(self):
        """Process cached nodes on main thread for thread-safe GUI updates"""
        try:
            if self.logger:
                self.logger.info(f" _process_cached_nodes called! hasattr: {hasattr(self, '_discovered_nodes_cache')}")
            
            if hasattr(self, '_discovered_nodes_cache'):
                nodes = self._discovered_nodes_cache
                if self.logger:
                    self.logger.info(f" Processing {len(nodes) if nodes else 0} cached nodes on main thread")
                
                if nodes:
                    self._update_discovered_nodes(nodes)
                else:
                    if self.logger:
                        self.logger.info(" No cached nodes to process (empty list)")
                
                # Clear cache
                self._discovered_nodes_cache = None
            else:
                if self.logger:
                    self.logger.warning(" _discovered_nodes_cache attribute not found!")
                    
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to process cached nodes: {e}")
                import traceback
                self.logger.error(traceback.format_exc())
    
    def _start_periodic_node_refresh(self):
        """Start periodic refresh of discovered nodes"""
        if hasattr(self, '_node_refresh_timer'):
            self._node_refresh_timer.stop()
        
        from PyQt5.QtCore import QTimer
        self._node_refresh_timer = QTimer()
        self._node_refresh_timer.timeout.connect(self._periodic_node_refresh)
        self._node_refresh_timer.start(5000)  # Refresh every 5 seconds
        
        if self.logger:
            self.logger.info(" Started periodic node refresh (5 seconds)")
    
    def _periodic_node_refresh(self):
        """Periodically refresh discovered nodes table"""
        try:
            if hasattr(self, 'network_discovery') and self.network_discovery and self.network_discovery.discovery_active:
                nodes = self.network_discovery.get_discovered_nodes()
                if self.logger:
                    self.logger.info(f" Periodic refresh found {len(nodes)} active nodes")
                
                # Remove offline nodes first
                self._remove_offline_nodes(nodes)
                
                # Update/add discovered nodes (no duplicates)
                if nodes:
                    self._update_discovered_nodes(nodes)
                    
        except Exception as e:
            if self.logger:
                self.logger.error(f"Periodic refresh failed: {e}")
    
    def _update_discovered_nodes(self, nodes):
        """Update discovered nodes table without duplicates"""
        try:
            if self.logger:
                self.logger.info(f" _update_discovered_nodes called with {len(nodes)} nodes")
            
            for i, node in enumerate(nodes):
                hostname = getattr(node, 'hostname', 'Unknown')
                ip_address = getattr(node, 'ip_address', 'Unknown')
                port = getattr(node, 'port', 5000)
                status = getattr(node, 'status', 'active')
                
                # Check if node already exists in table
                existing_row = self._find_node_in_table(ip_address, hostname)
                
                if existing_row >= 0:
                    # Update existing row
                    if self.logger:
                        self.logger.info(f"  Updating existing node {i+1}: {hostname} ({ip_address}:{port}) - {status}")
                    
                    self.discovered_nodes_table.setItem(existing_row, 0, QTableWidgetItem(hostname))
                    self.discovered_nodes_table.setItem(existing_row, 1, QTableWidgetItem(ip_address))
                    self.discovered_nodes_table.setItem(existing_row, 2, QTableWidgetItem(str(port)))
                    
                    status_text = " Available" if status == "active" else " Inactive"
                    self.discovered_nodes_table.setItem(existing_row, 3, QTableWidgetItem(status_text))
                else:
                    # Add new row
                    row = self.discovered_nodes_table.rowCount()
                    self.discovered_nodes_table.insertRow(row)
                    
                    if self.logger:
                        self.logger.info(f"  Adding new node {i+1}: {hostname} ({ip_address}:{port}) - {status}")
                    
                    self.discovered_nodes_table.setItem(row, 0, QTableWidgetItem(hostname))
                    self.discovered_nodes_table.setItem(row, 1, QTableWidgetItem(ip_address))
                    self.discovered_nodes_table.setItem(row, 2, QTableWidgetItem(str(port)))
                    
                    status_text = " Available" if status == "active" else " Inactive"
                    self.discovered_nodes_table.setItem(row, 3, QTableWidgetItem(status_text))
            
            # Force table refresh
            self.discovered_nodes_table.update()
            
            if self.logger:
                self.logger.info(f" Table updated successfully with {len(nodes)} nodes. Total rows: {self.discovered_nodes_table.rowCount()}")
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to update discovered nodes: {e}")
    
    def _find_node_in_table(self, ip_address: str, hostname: str) -> int:
        """Find if node already exists in table, return row index or -1"""
        try:
            for row in range(self.discovered_nodes_table.rowCount()):
                # Check IP address (column 1) - primary identifier
                table_ip = self.discovered_nodes_table.item(row, 1)
                if table_ip and table_ip.text() == ip_address:
                    return row
                
                # Also check hostname (column 0) as backup
                table_hostname = self.discovered_nodes_table.item(row, 0)
                if table_hostname and hostname in table_hostname.text():
                    return row
            
            return -1
            
        except Exception as e:
            if self.logger:
                self.logger.error(f"Error finding node in table: {e}")
            return -1
    
    def _remove_offline_nodes(self, active_nodes):
        """Remove nodes from table that are no longer active"""
        try:
            active_ips = {getattr(node, 'ip_address', '') for node in active_nodes}
            
            # Iterate backwards to avoid index issues when removing rows
            for row in range(self.discovered_nodes_table.rowCount() - 1, -1, -1):
                table_ip_item = self.discovered_nodes_table.item(row, 1)
                if table_ip_item:
                    table_ip = table_ip_item.text()
                    
                    # Don't remove local machine row
                    if "This Machine" in self.discovered_nodes_table.item(row, 0).text():
                        continue
                    
                    # Remove if not in active nodes
                    if table_ip not in active_ips:
                        hostname_item = self.discovered_nodes_table.item(row, 0)
                        hostname = hostname_item.text() if hostname_item else "Unknown"
                        
                        self.discovered_nodes_table.removeRow(row)
                        if self.logger:
                            self.logger.info(f" Removed offline node: {hostname} ({table_ip})")
                            
        except Exception as e:
            if self.logger:
                self.logger.error(f"Error removing offline nodes: {e}")
    
    def _connect_to_selected(self):
        """Connect to selected discovered node"""
        try:
            current_row = self.discovered_nodes_table.currentRow()
            if current_row < 0:
                self.show_error("Selection Error", "Please select a node from the discovery list to connect to")
                return
            
            machine_name = self.discovered_nodes_table.item(current_row, 0).text()
            host = self.discovered_nodes_table.item(current_row, 1).text()
            port = int(self.discovered_nodes_table.item(current_row, 2).text())
            
            if self.logger:
                self.logger.info(f" Attempting connection: {machine_name} -> {host}:{port}")
                self.logger.info(f" Note: Remote machine must be running HTTP server on this port")
            
            # Don't connect to self
            if "This Machine" in machine_name:
                self.show_info("Connection Info", "Cannot connect to your own machine")
                return
            
            # Show progress dialog briefly
            progress = QProgressDialog(f"Connecting to {machine_name}...", None, 0, 0, self)
            progress.setWindowTitle("Connecting")
            progress.setWindowModality(Qt.WindowModal)
            progress.show()
            
            # Process events to show dialog
            from PyQt5.QtWidgets import QApplication
            QApplication.processEvents()
            
            try:
                # Try to connect with short timeout
                success = self._connect_to_server(host, port)
                progress.close()
                
                if success:
                    QMessageBox.information(
                        self,
                        "Connection Success",
                        f"Successfully connected to {machine_name}!\n\n"
                        f"Server: {host}:{port}"
                    )
                else:
                    self.show_error(
                        "Connection Failed", 
                        f"Failed to connect to {machine_name} ({host}:{port})\n\n"
                        "Possible causes:\n"
                        " Remote machine is not running HTTP server\n" 
                        " Server is running on different port\n"
                        " Firewall blocking connection\n\n"
                        "Solution: Start the application on remote machine\n"
                        "and click 'Start Server' in Network tab."
                    )
            except Exception as e:
                progress.close()
                if self.logger:
                    self.logger.error(f"Connection error: {e}")
                self.show_error("Connection Error", f"Connection failed: {str(e)}")
            
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to connect to selected node: {e}")
            self.show_error("Connection Error", f"Failed to connect: {str(e)}")
    
    def _connect_to_server(self, host: str, port: int) -> bool:
        """Connect to server and return success status"""
        try:
            if not hasattr(self, 'network_client') or not self.network_client:
                if self.logger:
                    self.logger.error("Network client not initialized")
                return False
            
            # Try to connect using NetworkClient
            result = self.network_client.connect(host, port)
            
            if result:
                # Add to connected servers table
                row = self.connected_servers_table.rowCount()
                self.connected_servers_table.insertRow(row)
                
                # Try to get hostname or use IP
                hostname = host
                try:
                    import socket
                    hostname = socket.gethostbyaddr(host)[0]
                except:
                    hostname = host
                
                self.connected_servers_table.setItem(row, 0, QTableWidgetItem(hostname))
                self.connected_servers_table.setItem(row, 1, QTableWidgetItem(host))
                self.connected_servers_table.setItem(row, 2, QTableWidgetItem(str(port)))
                self.connected_servers_table.setItem(row, 3, QTableWidgetItem(" Connected"))
                
                if self.logger:
                    self.logger.info(f" Connected to server: {hostname} ({host}:{port})")
                
                return True
            else:
                if self.logger:
                    self.logger.error(f" Failed to connect to {host}:{port}")
                return False
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"Connection error: {e}")
            return False
    
    def _manual_connect(self):
        """Manual connect to server"""
        try:
            host = self.manual_host_input.text().strip()
            port = self.manual_port_input.value()
            
            if not host:
                self.show_error("Input Error", "Please enter host address")
                return
            
            self._connect_to_server(host, port)
            
        except Exception as e:
            if self.logger:
                self.logger.error(f"Manual connect failed: {e}")
            self.show_error("Connection Error", f"Failed to connect: {str(e)}")
    
    def _disconnect_server(self):
        """Disconnect from selected server"""
        try:
            current_row = self.connected_servers_table.currentRow()
            if current_row < 0:
                return
            
            server_id = self.connected_servers_table.item(current_row, 0).text()
            host, port = server_id.split(':')
            
            # Disconnect from server
            self.network_client.disconnect(host, int(port))
            
            # Remove from table
            self.connected_servers_table.removeRow(current_row)
            
            if self.logger:
                self.logger.info(f" Disconnected from server {server_id}")
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to disconnect: {e}")
    
    def _browse_remote_folders(self):
        """Browse remote folders (simplified - just browse, upload handled separately)"""
        try:
            current_row = self.connected_servers_table.currentRow()
            if current_row < 0:
                self.show_error("Selection Error", "Please select a connected server first")
                return
            
            host = self.connected_servers_table.item(current_row, 1).text()
            port = int(self.connected_servers_table.item(current_row, 2).text())
            hostname = self.connected_servers_table.item(current_row, 0).text()
            
            # Just browse remote folders
            browser_dialog = RemoteBrowserDialog(self.network_client, host, port, hostname, self)
            browser_dialog.exec_()
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to browse remote: {e}")
            self.show_error("Browse Error", f"Failed to browse remote server: {str(e)}")
    
    def _upload_files_to_selected_server(self):
        """Upload files to selected server - simplified and functional"""
        try:
            current_row = self.connected_servers_table.currentRow()
            if current_row < 0:
                self.show_error("Selection Error", "Please select a connected server first")
                return
            
            host = self.connected_servers_table.item(current_row, 1).text()
            port = int(self.connected_servers_table.item(current_row, 2).text())
            hostname = self.connected_servers_table.item(current_row, 0).text()
            
            # Select files to upload
            files, _ = QFileDialog.getOpenFileNames(
                self,
                f"Select files to upload to {hostname}",
                "",
                "All Files (*.*)"
            )
            
            if not files:
                return
                
            # Show progress dialog
            progress_dialog = QProgressDialog(f"Uploading files to {hostname}...", "Cancel", 0, len(files), self)
            progress_dialog.setWindowModality(Qt.WindowModal)
            progress_dialog.show()
            
            success_count = 0
            error_count = 0
            
            for i, file_path in enumerate(files):
                if progress_dialog.wasCanceled():
                    break
                    
                progress_dialog.setValue(i)
                progress_dialog.setLabelText(f"Uploading {os.path.basename(file_path)}...")
                QApplication.processEvents()
                
                # Try to upload file
                try:
                    result = self._upload_single_file(file_path, host, port)
                    if result:
                        success_count += 1
                        if self.logger:
                            self.logger.info(f" Uploaded: {os.path.basename(file_path)}")
                    else:
                        error_count += 1
                        if self.logger:
                            self.logger.error(f" Failed to upload: {os.path.basename(file_path)}")
                except Exception as e:
                    error_count += 1
                    if self.logger:
                        self.logger.error(f" Upload error for {os.path.basename(file_path)}: {e}")
            
            progress_dialog.close()
            
            # Show results
            if success_count > 0 or error_count > 0:
                message = f"Upload completed!\n\n Success: {success_count} files\n Failed: {error_count} files"
                if success_count > 0 and error_count == 0:
                    QMessageBox.information(self, "Upload Complete", message)
                elif success_count > 0 and error_count > 0:
                    QMessageBox.warning(self, "Upload Partially Complete", message)
                else:
                    QMessageBox.critical(self, "Upload Failed", message)
                    
        except Exception as e:
            if self.logger:
                self.logger.error(f"Upload files failed: {e}")
            self.show_error("Upload Error", f"Failed to upload files: {str(e)}")
    
    def _upload_single_file(self, file_path: str, host: str, port: int) -> bool:
        """Upload a single file to server via HTTP POST"""
        try:
            import requests
            
            # Prepare file for upload
            file_name = os.path.basename(file_path)
            
            with open(file_path, 'rb') as file:
                files = {'file': (file_name, file)}
                data = {}  # Can specify folder_id if needed
                
                # Upload via POST to /api/upload endpoint
                upload_url = f"http://{host}:{port}/api/upload"
                response = requests.post(upload_url, files=files, data=data, timeout=30)
                
                if response.status_code == 200:
                    result = response.json()
                    if result.get('success'):
                        if self.logger:
                            self.logger.info(f" Successfully uploaded {file_name} to {host}:{port}")
                        return True
                    else:
                        if self.logger:
                            self.logger.error(f" Upload failed: {result.get('error', 'Unknown error')}")
                        return False
                else:
                    if self.logger:
                        self.logger.error(f" Upload HTTP error {response.status_code}: {response.text}")
                    return False
            
        except Exception as e:
            if self.logger:
                self.logger.error(f"Single file upload failed: {e}")
            return False
    
    def _remote_search(self):
        """Perform remote search"""
        try:
            current_row = self.connected_servers_table.currentRow()
            if current_row < 0:
                self.show_error("Selection Error", "Please select a connected server")
                return
            
            # Get current query
            query = self.search_input.toPlainText().strip()
            if not query:
                self.show_error("Query Error", "Please enter a search query")
                return
            
            host = self.connected_servers_table.item(current_row, 1).text()
            port = int(self.connected_servers_table.item(current_row, 2).text())
            
            # Perform remote search
            results = self.network_client.search_remote(host, port, query, k=50)
            
            if results:
                # Display results in main search interface
                self._display_search_results(results)
                # Switch to search tab
                self.tabs.setCurrentIndex(0)
                
                if self.logger:
                    self.logger.info(f" Remote search returned {len(results)} results")
            else:
                self.show_info("Search Results", "No results found on remote server")
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"Remote search failed: {e}")
            self.show_error("Search Error", f"Remote search failed: {str(e)}")
    
    def _load_remote_index(self):
        """Load remote index"""
        try:
            current_row = self.connected_servers_table.currentRow()
            if current_row < 0:
                self.show_error("Selection Error", "Please select a connected server")
                return
            
            host = self.connected_servers_table.item(current_row, 1).text()
            port = int(self.connected_servers_table.item(current_row, 2).text())
            
            # Get available indexes
            indexes = self.network_client.get_shared_indexes(host, port)
            
            if not indexes:
                self.show_info("Remote Indexes", "No shared indexes available")
                return
            
            # Let user choose index
            index_names = [f"{idx['name']} ({idx['path']})" for idx in indexes]
            selected, ok = QInputDialog.getItem(
                self, "Select Remote Index", "Choose index to load:", index_names, 0, False
            )
            
            if ok and selected:
                # Find selected index
                selected_index = None
                for idx in indexes:
                    if f"{idx['name']} ({idx['path']})" == selected:
                        selected_index = idx
                        break
                
                if selected_index:
                    # Load remote index using the same pattern as local unified index
                    self._load_remote_unified_index(host, port, selected_index)
                        
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to load remote index: {e}")
            self.show_error("Load Error", f"Failed to load remote index: {str(e)}")
    
    def _refresh_discovered_nodes(self):
        """Refresh discovered nodes list"""
        try:
            # Clear current table
            self.discovered_nodes_table.setRowCount(0)
            
            # Start discovery
            self._discover_networks()
            
            if self.logger:
                self.logger.info(" Refreshed network discovery")
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"Failed to refresh discovered nodes: {e}")
            self.show_error("Refresh Error", f"Failed to refresh nodes: {str(e)}")
    
    def _browse_remote_server(self):
        """Browse remote server - alias for _browse_remote_folders"""
        self._browse_remote_folders()
    
    def _setup_menu_bar(self):
        """Setup application menu bar"""
        menubar = self.menuBar()
        
        # File menu
        file_menu = menubar.addMenu("File")
        
        # System actions
        build_action = QAction(" Build System...", self)
        build_action.triggered.connect(self._smart_build_system)
        file_menu.addAction(build_action)
        
        load_action = QAction(" Smart Load...", self)
        load_action.triggered.connect(self._smart_load_system)
        file_menu.addAction(load_action)
        
        file_menu.addSeparator()
        
        # Export actions
        export_action = QAction("Export Results...", self)
        export_action.triggered.connect(self._export_current_results)
        file_menu.addAction(export_action)
        
        file_menu.addSeparator()
        
        # Exit
        exit_action = QAction("Exit", self)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # Tools menu
        tools_menu = menubar.addMenu("Tools")
        
        optimize_action = QAction("Optimize System", self)
        optimize_action.triggered.connect(self._optimize_system)
        tools_menu.addAction(optimize_action)
        
        cleanup_action = QAction("Cleanup System", self)
        cleanup_action.triggered.connect(self._cleanup_system)
        tools_menu.addAction(cleanup_action)
        
        # View menu
        view_menu = menubar.addMenu("View")
        
        refresh_action = QAction("Refresh", self)
        refresh_action.triggered.connect(self._refresh_all)
        view_menu.addAction(refresh_action)
        
        # Help menu
        help_menu = menubar.addMenu("Help")
        
        about_action = QAction("About", self)
        about_action.triggered.connect(self._show_about)
        help_menu.addAction(about_action)
    
    def _setup_status_bar(self):
        """Setup status bar"""
        self.status_bar = self.statusBar()
        self.status_bar.showMessage("Ready")
    
    def _initialize_system(self):
        """Initialize retrieval system"""
        try:
            if not self.system:
                # Initialize system - OpenAI only
                self.system = EnhancedRetrievalSystem(verbose=False)
                self.logger = self.system.logger
            
            # Create chat widget now that system is available
            if hasattr(self, 'tab_widget') and self.system:
                chat_tab_index = -1
                for i in range(self.tab_widget.count()):
                    if "Chat Interface" in self.tab_widget.tabText(i):
                        chat_tab_index = i
                        break
                
                if chat_tab_index == -1:
                    self.chat_widget = ChatInterface(self.system)
                    self.chat_widget.search_requested.connect(self._perform_search)
                    self.tab_widget.addTab(self.chat_widget, " Chat Interface")
            
            self._update_system_info()
            self.status_bar.showMessage("System initialized")
            
        except Exception as e:
            QMessageBox.critical(self, "Initialization Error", f"Failed to initialize system:\n{str(e)}")
    
    def _on_search_clicked(self):
        """Handle search button click"""
        query = self.search_input.toPlainText().strip()
        if query:
            self._perform_search(query)
        else:
            QMessageBox.warning(self, "Warning", "Please enter a search query.")
    
    def _perform_search(self, query: str):
        """Perform search operation"""
        if not self.system:
            self._initialize_system()
            
        if not self.system:
            QMessageBox.warning(self, "Warning", "System not ready. Please build or load a system first.")
            return
        
        # Create search options using SearchOptions class
        options = SearchOptions(
            mode=self.mode_combo.currentText(),
            limit=self.limit_spinbox.value(),
            include_temporal_context=self.temporal_checkbox.isChecked(),
            include_explanations=self.explanations_checkbox.isChecked()
        )
        
        # Show progress
        progress_id = f"search_{time.time()}"
        self.progress_manager.show_progress(progress_id, f"Searching: {query[:30]}...", 100)
        
        # Clear previous translation info
        self.translation_info.setVisible(False)
        
        # Update initial status to show translation step
        self.progress_manager.update_progress(progress_id, 10, "Translating query...")
        
        # Create enhanced worker thread that handles translation display
        worker = WorkerThread(self._search_with_translation_info, query, options)
        worker.progress_updated.connect(lambda c, t, m: self.progress_manager.update_progress(progress_id, int(c * 100 / t), m))
        worker.result_ready.connect(lambda result: self._on_search_completed_with_translation(result, progress_id))
        worker.error_occurred.connect(lambda error: self._on_search_error(error, progress_id))
        worker.start()
        
        self.worker_threads.append(worker)
        self.status_bar.showMessage(f"Searching for: {query}")
    
    def _on_chat_frame_selected(self, frame_id: str):
        """Handle frame selection from chat interface"""
        try:
            if hasattr(self.results_widget, 'find_and_select_frame'):
                self.results_widget.find_and_select_frame(frame_id)
        except Exception as e:
            self.logger.warning(f"Failed to sync frame selection: {e}")
    
    def _sync_search_results_to_chat(self, search_results):
        """Sync search results to chat interface results panel"""
        try:
            if hasattr(self, 'chat_widget') and self.chat_widget:
                self.logger.info(f"Syncing {len(search_results)} results to chat interface")
                self.chat_widget._update_search_results_display(search_results)
                self.logger.info("Successfully synced results to chat interface")
            else:
                self.logger.warning("Chat widget not available for sync")
        except Exception as e:
            self.logger.error(f"Failed to sync search results to chat: {e}")
            import traceback
            self.logger.error(f"Traceback: {traceback.format_exc()}")
    
    def _quick_search(self, query: str):
        """Perform quick search"""
        try:
            self.search_input.setPlainText(query)
            # Move cursor to end to avoid position errors (only if text is not empty)
            if query.strip():
                cursor = self.search_input.textCursor()
                cursor.movePosition(QTextCursor.End)
                self.search_input.setTextCursor(cursor)
        except Exception as e:
            # Fallback: just set text without cursor manipulation
            self.search_input.clear()
            self.search_input.insertPlainText(query)
        self._perform_search(query)
    
    def _search_with_translation_info(self, query: str, options):
        """Perform search with translation info display"""
        # Log search parameters for debugging
        if hasattr(self, 'logger') and self.logger:
            self.logger.info(f" Starting search with limit: {options.limit}")
        
        # Get translation info if available
        translation_info = None
        if hasattr(self.system, 'query_translator') and self.system.query_translator:
            try:
                translation_struct = self.system.query_translator.translate_query(query)
                if translation_struct and translation_struct.detected_language != "en":
                    translation_info = {
                        'original': query,
                        'translated': translation_struct.clip_prompt,
                        'language': translation_struct.detected_language,
                        'confidence': translation_struct.confidence,
                        'scene_context': getattr(translation_struct, 'scene_context', None),
                        'main_subjects': getattr(translation_struct, 'main_subjects', None)
                    }
            except Exception as e:
                pass
        
        # Perform actual search with SearchOptions object
        results = self.system.search(query, options)
        
        # Log results count for debugging
        if hasattr(self, 'logger') and self.logger:
            self.logger.info(f" Search returned {len(results)} results (limit was {options.limit})")
        
        return (results, translation_info)
    
    def _display_translation_info(self, translation_info: dict):
        """Display translation information in the UI"""
        if not translation_info:
            return
        
        # Create translation display text
        lang_name = {
            'vi': 'Vietnamese', 'zh': 'Chinese', 'ja': 'Japanese', 
            'ko': 'Korean', 'th': 'Thai', 'id': 'Indonesian'
        }.get(translation_info['language'], translation_info['language'])
        
        confidence_text = f"({translation_info['confidence']:.2f})" if translation_info['confidence'] < 0.9 else ""
        
        translation_text = f" Translated from {lang_name} {confidence_text}: \"{translation_info['original']}\"  \"{translation_info['translated']}\""
        
        # Add detailed info if available
        details = []
        if translation_info.get('main_subjects'):
            details.append(f"Subjects: {translation_info['main_subjects']}")
        if translation_info.get('scene_context'):
            details.append(f"Context: {translation_info['scene_context']}")
        
        if details:
            translation_text += f" | {' | '.join(details)}"
        
        self.translation_info.setText(translation_text)
        self.translation_info.setVisible(True)
    
    def _show_translation_info(self, original_query: str, translated_query: str):
        """Show translation information to user"""
        if original_query != translated_query:
            self.status_bar.showMessage(f"Translated: '{original_query}' -> '{translated_query}'", 5000)
    
    def _on_search_completed_with_translation(self, result_tuple, progress_id: str):
        """Handle search completion with translation info"""
        self.progress_manager.finish_progress(progress_id)
        
        if isinstance(result_tuple, tuple) and len(result_tuple) == 2:
            results, translation_info = result_tuple
        else:
            results = result_tuple
            translation_info = None
        
        # Log initial results count
        initial_count = len(results)
        if hasattr(self, 'logger') and self.logger:
            self.logger.info(f" Processing {initial_count} search results")
        
        # Filter results if "Hide Result displayed" is checked
        if self.hide_displayed_checkbox.isChecked():
            filtered_results = []
            for result in results:
                file_path = result.metadata.file_path
                if file_path not in self.displayed_results and file_path not in self.exported_results:
                    filtered_results.append(result)
            results = filtered_results
            
            # Log filtering results
            if hasattr(self, 'logger') and self.logger:
                self.logger.info(f" Filtered results: {initial_count}  {len(results)} (hide displayed was enabled)")
        
        # Add current results to displayed set
        for result in results:
            self.displayed_results.add(result.metadata.file_path)
        
        self.current_results = results
        self.results_widget.display_results(results)
        
        # Sync results to chat interface
        self._sync_search_results_to_chat(results)
        
        # Display translation info if available
        if translation_info:
            self._display_translation_info(translation_info)
        
        # Update status
        original_count = len(result_tuple[0]) if isinstance(result_tuple, tuple) else len(result_tuple)
        filtered_count = len(results)
        
        if self.hide_displayed_checkbox.isChecked() and filtered_count < original_count:
            status_msg = f"Search completed - {filtered_count} new results found ({original_count - filtered_count} hidden)"
        else:
            status_msg = f"Search completed - {filtered_count} results found"
            
        if translation_info:
            status_msg += f" (translated from {translation_info['language']})"
        
        self.status_bar.showMessage(status_msg)
    
    def _on_search_completed(self, results: List[SearchResult], progress_id: str):
        """Handle search completion (legacy method for compatibility)"""
        self._on_search_completed_with_translation(results, progress_id)
    
    def _on_search_error(self, error: str, progress_id: str):
        """Handle search error"""
        self.progress_manager.finish_progress(progress_id)
        
        self.status_bar.showMessage("Search failed")
        QMessageBox.critical(self, "Search Error", f"Search failed:\n{error}")
    
    def _clear_tracked_results(self):
        """Clear tracked displayed and exported results"""
        reply = QMessageBox.question(
            self, 
            "Clear Tracked Results", 
            "This will clear all tracked displayed and exported results. Continue?",
            QMessageBox.Yes | QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            self.displayed_results.clear()
            self.exported_results.clear()
            self.status_bar.showMessage("Tracked results cleared - all results will be shown in next search")
    
    def _on_selection_changed(self, selected_items: List[KeyframeMetadata]):
        """Handle selection change in results"""
        count = len(selected_items)
        self.status_bar.showMessage(f"{count} items selected")
        
        # Update chat interface with selected frames
        if hasattr(self, 'chat_widget') and self.chat_widget:
            self.chat_widget.set_selected_frames(selected_items)
    
    def _export_current_results(self):
        """Export all current results to CSV list"""
        if not self.current_results:
            QMessageBox.information(self, "Information", "No search results to export.")
            return
        
        # Add all current results to CSV list
        added_count = 0
        for result in self.current_results:
            already_exists = any(
                csv_result.metadata.file_path == result.metadata.file_path 
                for csv_result in self.results_widget.csv_results
            )
            
            if not already_exists:
                self.results_widget.csv_results.append(result)
                self.results_widget._add_csv_list_item(result)
                added_count += 1
        
        self.results_widget._update_csv_tab_title()
        
        self.results_widget.csv_tab_widget.setCurrentIndex(1)
        
        if added_count > 0:
            QMessageBox.information(
                self, 
                "Success", 
                f"Added {added_count} results to CSV list.\nDuplicates were skipped."
            )
        else:
            QMessageBox.information(
                self, 
                "Info", 
                "All current results were already in the CSV list."
            )

    def _filter_frames(self):
        """Filter keyframes from video"""
        folder = QFileDialog.getExistingDirectory(self, "Select Video Folder")
        if not folder:
            return

        if not self.system:
            self._initialize_system()
            
        progress_id = f"filter_{time.time()}"
        self.progress_manager.show_progress(progress_id, "Processing Videos", 100)
        
        try:
            def process_with_progress(input_path):
                from video_frame_filter import process_videos
                return process_videos(input_path)
                
            worker = WorkerThread(process_with_progress, folder)
            
            worker.progress_updated.connect(
                lambda c, t, m: self.progress_manager.update_progress(progress_id, int((c/t)*100), m)
            )
            worker.result_ready.connect(
                lambda result: self._on_filter_completed(result, progress_id)
            )
            worker.error_occurred.connect(
                lambda error: self._on_filter_error(error, progress_id)
            )
            
            self.status_bar.showMessage("Processing videos...")
            worker.start()
            self.worker_threads.append(worker)
            
        except Exception as e:
            self.progress_manager.finish_progress(progress_id)
            QMessageBox.critical(self, "Error", f"Failed to start video processing:\n{str(e)}")
            
    def _on_filter_completed(self, saved_count: int, progress_id: str):
        """Handle video frame filter completion"""
        self.progress_manager.finish_progress(progress_id)
        self.status_bar.showMessage(f"Video processing completed - {saved_count} frames extracted")
        
        QMessageBox.information(
            self,
            "Processing Complete",
            f"Successfully extracted {saved_count} keyframes.\n\nYou can now build the system using these frames."
        )
        
    def _on_filter_error(self, error: str, progress_id: str):
        """Handle video frame filter error"""
        self.progress_manager.finish_progress(progress_id)
        self.status_bar.showMessage("Video processing failed")
        QMessageBox.critical(self, "Processing Error", f"Video processing failed:\n{error}")
    
    def _smart_build_system(self):
        """Smart build system: builds from keyframes and auto-creates portable package"""
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Build System - Select Folders")
        dialog.setMinimumWidth(500)
        dialog.setMinimumHeight(200)
        
        layout = QVBoxLayout(dialog)
        
        instruction_label = QLabel(
            "Please select both the keyframes folder and map folder.\n"
            "The map folder should contain CSV files with frame mappings."
        )
        instruction_label.setWordWrap(True)
        layout.addWidget(instruction_label)
        
        # Keyframes folder selection
        keyframes_layout = QHBoxLayout()
        keyframes_label = QLabel("Keyframes Folder:")
        keyframes_label.setMinimumWidth(120)
        self.keyframes_path_edit = QLineEdit()
        self.keyframes_path_edit.setPlaceholderText("Select folder containing keyframe images...")
        keyframes_browse_btn = QPushButton("Browse...")
        
        def select_keyframes_folder():
            folder = QFileDialog.getExistingDirectory(dialog, "Select Keyframes Folder")
            if folder:
                self.keyframes_path_edit.setText(folder)
        
        keyframes_browse_btn.clicked.connect(select_keyframes_folder)
        
        keyframes_layout.addWidget(keyframes_label)
        keyframes_layout.addWidget(self.keyframes_path_edit)
        keyframes_layout.addWidget(keyframes_browse_btn)
        layout.addLayout(keyframes_layout)
        
        # Build format selection
        format_group = QGroupBox("Build Format")
        format_layout = QVBoxLayout(format_group)
        
        self.legacy_build_radio = QRadioButton("Legacy Build (Original System)")
        self.unified_build_radio = QRadioButton(" Unified Build (10x Faster, Single File)")
        self.unified_build_radio.setChecked(True)  # Default to new system
        
        # Connect radio buttons to enable/disable incremental options
        self.unified_build_radio.toggled.connect(self._on_build_format_changed)
        self.legacy_build_radio.toggled.connect(self._on_build_format_changed)
        
        format_layout.addWidget(self.unified_build_radio)
        format_layout.addWidget(self.legacy_build_radio)
        
        # Add performance info
        perf_info = QLabel(
            " Unified Build: Single .rvdb file, 10x faster, instant loading, incremental updates\n"
            " Legacy Build: Multiple files, compatible with older versions"
        )
        perf_info.setStyleSheet("color: #666; font-size: 10px;")
        format_layout.addWidget(perf_info)
        
        layout.addWidget(format_group)
        
        # Incremental build options
        incremental_group = QGroupBox(" Memory & Resume Options")
        incremental_layout = QVBoxLayout(incremental_group)
        
        # Resume from existing checkbox
        self.resume_build_checkbox = QCheckBox(" Resume from existing .rvdb file (if available)")
        self.resume_build_checkbox.setChecked(True)
        self.resume_build_checkbox.setToolTip("Skip already processed files from existing .rvdb to continue building")
        self.resume_build_checkbox.toggled.connect(self._update_browse_button_text)
        incremental_layout.addWidget(self.resume_build_checkbox)
        
        # Chunk size selection
        chunk_layout = QHBoxLayout()
        chunk_label = QLabel("Chunk Size:")
        chunk_label.setMinimumWidth(80)
        self.chunk_size_spinbox = QSpinBox()
        self.chunk_size_spinbox.setRange(100, 5000)
        self.chunk_size_spinbox.setValue(1000)
        self.chunk_size_spinbox.setSuffix(" images")
        self.chunk_size_spinbox.setToolTip("Number of images processed per chunk (lower = less RAM usage)")
        
        chunk_info = QLabel("(Lower = Less RAM/GPU usage)")
        chunk_info.setStyleSheet("color: #666; font-size: 10px;")
        
        chunk_layout.addWidget(chunk_label)
        chunk_layout.addWidget(self.chunk_size_spinbox)
        chunk_layout.addWidget(chunk_info)
        chunk_layout.addStretch()
        
        incremental_layout.addLayout(chunk_layout)
        
        # Tips
        tips_label = QLabel(
            " Tips:\n"
            " Use resume to continue interrupted builds\n"
            " Lower chunk size if you get memory errors\n"
            " You can delete original keyframes after build"
        )
        tips_label.setStyleSheet("color: #444; font-size: 10px; background: #f0f0f0; padding: 8px; border-radius: 4px;")
        incremental_layout.addWidget(tips_label)
        
        layout.addWidget(incremental_group)
        
        # Store reference for enabling/disabling
        self.incremental_group = incremental_group

        # Output file selection
        output_layout = QHBoxLayout()
        output_label = QLabel("Output File:")
        output_label.setMinimumWidth(120)
        self.output_path_edit = QLineEdit()
        self.output_path_edit.setPlaceholderText("Select output .rvdb file path...")
        self.output_browse_btn = QPushButton("Browse...")
        
        def select_output_file():
            file_dialog = QFileDialog(self)
            file_dialog.setNameFilter("Unified Index Files (*.rvdb)")
            file_dialog.setDefaultSuffix("rvdb")
            
            # Set dialog mode based on resume checkbox
            resume_enabled = getattr(self, 'resume_build_checkbox', None)
            if resume_enabled and resume_enabled.isChecked():
                # Resume mode: allow selecting existing files without overwrite warning
                file_dialog.setFileMode(QFileDialog.ExistingFile)
                file_dialog.setAcceptMode(QFileDialog.AcceptOpen)
                file_dialog.setWindowTitle("Select Existing .rvdb File to Resume/Append")
            else:
                # New file mode: show save dialog with overwrite warnings
                file_dialog.setFileMode(QFileDialog.AnyFile)
                file_dialog.setAcceptMode(QFileDialog.AcceptSave)
                file_dialog.setWindowTitle("Create New .rvdb File")
            
            if file_dialog.exec_() == QFileDialog.Accepted:
                selected_files = file_dialog.selectedFiles()
                if selected_files:
                    self.output_path_edit.setText(selected_files[0])
        
        self.output_browse_btn.clicked.connect(select_output_file)
        
        output_layout.addWidget(output_label)
        output_layout.addWidget(self.output_path_edit)
        output_layout.addWidget(self.output_browse_btn)
        layout.addLayout(output_layout)
        
        # Initialize button text based on resume checkbox state
        self._update_browse_button_text()

        # Map folder selection
        map_layout = QHBoxLayout()
        map_label = QLabel("Map Folder:")
        map_label.setMinimumWidth(120)
        self.map_path_edit = QLineEdit()
        self.map_path_edit.setPlaceholderText("Select folder containing CSV mapping files...")
        map_browse_btn = QPushButton("Browse...")
        
        def select_map_folder():
            folder = QFileDialog.getExistingDirectory(dialog, "Select Map Folder")
            if folder:
                self.map_path_edit.setText(folder)
        
        map_browse_btn.clicked.connect(select_map_folder)
        
        map_layout.addWidget(map_label)
        map_layout.addWidget(self.map_path_edit)
        map_layout.addWidget(map_browse_btn)
        layout.addLayout(map_layout)
        
        # Portable package option
        portable_checkbox = QCheckBox("Create portable package after building")
        portable_checkbox.setChecked(True)
        portable_checkbox.setToolTip("Recommended for sharing with other machines")
        layout.addWidget(portable_checkbox)
        
        # Dialog buttons
        button_layout = QHBoxLayout()
        ok_button = QPushButton("Build System")
        cancel_button = QPushButton("Cancel")
        
        ok_button.clicked.connect(dialog.accept)
        cancel_button.clicked.connect(dialog.reject)
        
        button_layout.addStretch()
        button_layout.addWidget(cancel_button)
        button_layout.addWidget(ok_button)
        layout.addLayout(button_layout)
        
        if dialog.exec_() != QDialog.Accepted:
            return
        
        keyframes_folder = self.keyframes_path_edit.text().strip()
        map_folder = self.map_path_edit.text().strip()
        output_file = self.output_path_edit.text().strip()
        create_portable = portable_checkbox.isChecked()
        use_unified_format = self.unified_build_radio.isChecked()
        
        if not keyframes_folder:
            QMessageBox.warning(self, "Warning", "Please select a keyframes folder.")
            return
        
        if not map_folder:
            QMessageBox.warning(self, "Warning", "Please select a map folder.")
            return
        
        if use_unified_format and not output_file:
            QMessageBox.warning(self, "Warning", "Please select an output .rvdb file path for Unified Build.")
            return
        
        # Check if output file exists and handle appropriately
        if use_unified_format and os.path.exists(output_file):
            resume_enabled = self.resume_build_checkbox.isChecked()
            if resume_enabled:
                # User wants to resume/append - show confirmation
                reply = QMessageBox.question(
                    self,
                    "Resume Build",
                    f" Output file exists: {os.path.basename(output_file)}\n"
                    f" Resume mode: ENABLED\n\n"
                    f"This will:\n"
                    f" Skip already processed images\n"
                    f" Add new images to existing index\n"
                    f" Preserve existing data\n\n"
                    f"Continue with incremental build?",
                    QMessageBox.Yes | QMessageBox.No,
                    QMessageBox.Yes
                )
                if reply == QMessageBox.No:
                    return
            else:
                # User doesn't want to resume but file exists - confirm overwrite
                reply = QMessageBox.question(
                    self,
                    "File Exists",
                    f"Output file already exists:\n{output_file}\n\n"
                    f"Do you want to overwrite it?\n\n"
                    f" Tip: Check 'Resume from existing .rvdb' to append new data instead.",
                    QMessageBox.Yes | QMessageBox.No,
                    QMessageBox.No
                )
                if reply == QMessageBox.No:
                    return
        
        if not os.path.exists(keyframes_folder):
            QMessageBox.warning(self, "Warning", f"Keyframes folder does not exist:\n{keyframes_folder}")
            return
        
        if not os.path.exists(map_folder):
            QMessageBox.warning(self, "Warning", f"Map folder does not exist:\n{map_folder}")
            return
        
        if not self.system:
            self._initialize_system()
        
        # Handle unified vs legacy build
        if use_unified_format:
            self._start_unified_build(keyframes_folder, map_folder, output_file)
        else:
            # Legacy build
            progress_id = f"smart_build_{time.time()}"
            self.progress_manager.show_progress(progress_id, "Building System (Legacy)", 100)
            
            self._build_info = {
                'keyframes_folder': keyframes_folder,
                'map_folder': map_folder,
                'create_portable': create_portable,
                'progress_id': progress_id
            }
            
            worker = WorkerThread(self.system.build_system_with_map, keyframes_folder, map_folder, True, True)
            worker.progress_updated.connect(lambda c, t, m: self.progress_manager.update_progress(progress_id, c if t <= 100 else int(c * 100 / t), m))
            worker.result_ready.connect(lambda result: self._on_smart_build_completed(result))
            worker.error_occurred.connect(lambda error: self._on_build_error(error, progress_id))
            worker.start()
            
            self.worker_threads.append(worker)
    
    def _start_unified_build(self, keyframes_folder: str, map_folder: str, output_file: str):
        """Start unified build process with user-selected output file"""
        try:
            from unified_builder import add_unified_index_support
            
            # Add unified index support to system
            unified_builder = add_unified_index_support(self.system)
            
            progress_id = f"unified_build_{time.time()}"
            self.progress_manager.show_progress(progress_id, " Building Unified Index", 100)
            
            # Get CSV mappings from map folder
            csv_mappings = {}
            if os.path.exists(map_folder):
                for file in os.listdir(map_folder):
                    if file.endswith('.csv'):
                        csv_path = os.path.join(map_folder, file)
                        csv_mappings[os.path.splitext(file)[0]] = csv_path
            
            # Use user-provided output file path
            # (output_file is already passed as parameter)
            
            # Create worker first
            worker = None
            
            def run_unified_build():
                """Run unified build in thread"""
                try:
                    # Progress callback to update UI 
                    def update_progress(progress, message):
                        self.progress_manager.update_progress(progress_id, progress, message)
                    
                    # Get incremental build options from UI
                    resume_from_existing = self.resume_build_checkbox.isChecked()
                    chunk_size = self.chunk_size_spinbox.value()
                    
                    # Create unified index with incremental options
                    stats = unified_builder.create_unified_index_fast(
                        keyframes_dir=keyframes_folder,
                        output_path=output_file,
                        csv_mappings=csv_mappings,
                        progress_callback=update_progress,
                        resume_from_existing=resume_from_existing,
                        chunk_size=chunk_size
                    )
                    return {'success': True, 'stats': stats, 'output_file': output_file}
                except Exception as e:
                    return {'success': False, 'error': str(e)}
            
            # Run in worker thread
            worker = WorkerThread(run_unified_build)
            worker.progress_updated.connect(lambda c, t, m: self.progress_manager.update_progress(progress_id, min(95, int(c)), m))
            worker.result_ready.connect(lambda result: self._on_unified_build_completed(result, progress_id))
            worker.error_occurred.connect(lambda error: self._on_build_error(error, progress_id))
            worker.start()
            
            self.worker_threads.append(worker)
            
        except ImportError:
            QMessageBox.critical(
                self, 
                "Unified Build Not Available", 
                "Unified build requires additional dependencies:\n\n"
                "pip install h5py lz4\n\n"
                "Please install and try again, or use Legacy Build."
            )
        except Exception as e:
            QMessageBox.critical(self, "Build Error", f"Failed to start unified build:\n{str(e)}")
    
    def _on_build_format_changed(self):
        """Enable/disable incremental options based on build format"""
        is_unified = self.unified_build_radio.isChecked()
        self.incremental_group.setEnabled(is_unified)
        
        if not is_unified:
            # Disable incremental options for legacy build
            self.resume_build_checkbox.setChecked(False)
        else:
            # Enable defaults for unified build
            self.resume_build_checkbox.setChecked(True)
        
        # Update browse button text based on resume mode
        self._update_browse_button_text()
    
    def _update_browse_button_text(self):
        """Update browse button text based on resume checkbox state"""
        try:
            if hasattr(self, 'output_browse_btn') and hasattr(self, 'resume_build_checkbox'):
                if self.resume_build_checkbox.isChecked():
                    self.output_browse_btn.setText("Browse Existing...")
                else:
                    self.output_browse_btn.setText("Browse New...")
        except Exception:
            pass
    
    def _on_unified_build_completed(self, result: Dict, progress_id: str):
        """Handle unified build completion"""
        try:
            if result['success']:
                stats = result['stats']
                output_file = result['output_file']
                
                # Update progress to completion
                self.progress_manager.update_progress(progress_id, 100, " Unified index created successfully!")
                
                # Show success message with detailed stats including incremental info
                resumed_info = f" Resumed: {stats.get('resumed_files', 0)} files\n" if stats.get('resumed_files', 0) > 0 else ""
                chunks_info = f" Chunks processed: {stats.get('chunks_processed', 0)}\n" if stats.get('chunks_processed', 0) > 0 else ""
                checkpoints_info = f" Checkpoints saved: {stats.get('checkpoints_saved', 0)}\n" if stats.get('checkpoints_saved', 0) > 0 else ""
                
                success_msg = (
                    f" Unified Index Built Successfully!\n\n"
                    f" Performance Stats:\n"
                    f" Total files: {stats.get('total_files', 0)}\n"
                    f" Files processed: {stats['processed_files']}\n"
                    f"{resumed_info}"
                    f" Build time: {stats['total_build_time']:.2f}s\n"
                    f" {stats.get('estimated_speedup', 'Much faster!')}\n"
                    f"{chunks_info}"
                    f"{checkpoints_info}"
                    f" File size: {stats['index_size'] / 1024 / 1024:.2f} MB\n"
                    f" Compression: {stats['compression_ratio']:.1f}x smaller\n\n"
                    f" Output: {output_file}\n\n"
                    f" Features enabled:\n"
                    f" Instant loading (memory-mapped)\n"
                    f" Incremental updates & resume\n" 
                    f" Memory-efficient chunked processing\n"
                    f" Single file format\n"
                    f" Built-in thumbnails"
                )
                
                # Ask if user wants to load the new index immediately
                reply = QMessageBox.question(
                    self,
                    "Build Complete - Load Index?", 
                    success_msg + "\n\n" + "Load this index now?",
                    QMessageBox.Yes | QMessageBox.No,
                    QMessageBox.Yes
                )
                
                if reply == QMessageBox.Yes:
                    self._load_unified_index(output_file)
            else:
                # Build failed
                self.progress_manager.update_progress(progress_id, 0, " Build failed")
                QMessageBox.critical(
                    self,
                    "Build Failed",
                    f"Unified build failed:\n\n{result['error']}\n\n"
                    f"You can try Legacy Build instead."
                )
                
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Error handling build result:\n{str(e)}")
        finally:
            self.progress_manager.finish_progress(progress_id)
    
    def _load_unified_index(self, index_file: str):
        """Load unified index file"""
        try:
            from unified_builder import add_unified_index_support
            
            # Add unified index support to system  
            unified_builder = add_unified_index_support(self.system)
            
            progress_id = f"load_unified_{time.time()}"
            self.progress_manager.show_progress(progress_id, " Loading Unified Index", 100)
            
            def load_index():
                try:
                    stats = unified_builder.load_unified_index_fast(index_file)
                    return {'success': True, 'stats': stats}
                except Exception as e:
                    return {'success': False, 'error': str(e)}
            
            worker = WorkerThread(load_index)
            worker.result_ready.connect(lambda result: self._on_unified_load_completed(result, progress_id))
            worker.error_occurred.connect(lambda error: self._on_build_error(error, progress_id))
            worker.start()
            
            self.worker_threads.append(worker)
            
        except Exception as e:
            QMessageBox.critical(self, "Load Error", f"Failed to load unified index:\n{str(e)}")
    
    def _load_remote_unified_index(self, host: str, port: int, selected_index: Dict):
        """Load remote unified index using the same pattern as local unified index"""
        try:
            if not self.system:
                self._initialize_system()
            
            from unified_builder import add_unified_index_support
            
            # Add unified index support to system  
            unified_builder = add_unified_index_support(self.system)
            
            progress_id = f"load_remote_unified_{time.time()}"
            self.progress_manager.show_progress(progress_id, f" Loading Remote Index: {selected_index['name']}", 100)
            
            def load_remote_index():
                try:
                    # Load remote index and get actual implementation
                    result = self.network_client.load_remote_index(
                        host, port, selected_index['index_id']
                    )
                    
                    if not result['success']:
                        return result
                    
                    # Get the actual remote index instance
                    remote_index = result['remote_index']
                    index_info = result['index_info']
                    
                    # ACTUALLY integrate remote index with system
                    # This is the key part - we set system's index to the remote index
                    if hasattr(self.system, 'faiss_retriever') and self.system.faiss_retriever:
                        # Replace or supplement existing retriever with remote index capability
                        self.system.remote_index = remote_index
                        
                        # CRITICAL: Set unified_builder for thumbnail support
                        # Remote index should have unified builder capabilities too
                        if hasattr(remote_index, 'unified_index'):
                            self.system.unified_builder = remote_index
                            if self.logger:
                                self.logger.info(f" Set remote unified_builder for thumbnail support")
                        else:
                            if self.logger:
                                self.logger.warning(f" Remote index doesn't have unified_index property")
                        
                        # Update system status to reflect remote index
                        if hasattr(self.system, 'status'):
                            self.system.status.index_loaded = True
                            self.system.status.is_ready = True
                    
                    # Store remote index reference for system use
                    if not hasattr(self.system, 'remote_indexes'):
                        self.system.remote_indexes = []
                    
                    remote_index_info = {
                        'host': host,
                        'port': port,
                        'index_id': selected_index['index_id'],
                        'name': selected_index['name'],
                        'url': result['connection_url'],
                        'instance': remote_index,  # Store the actual instance
                        'total_vectors': index_info.get('total_vectors', 0)
                    }
                    self.system.remote_indexes.append(remote_index_info)
                    
                    # Create real stats from actual remote index
                    stats = {
                        'success': True,
                        'total_load_time': 0.1,
                        'estimated_speedup': 'Network access - no local storage needed!',
                        'memory_mapped': True,
                        'remote': True,
                        'index_info': {
                            'processed_files': index_info.get('total_vectors', 0),
                            'index_type': 'Remote Unified Index',
                            'source': f"{host}:{port}",
                            'total_vectors': index_info.get('total_vectors', 0)
                        }
                    }
                    
                    return {'success': True, 'stats': stats, 'remote_index': remote_index}
                    
                except Exception as e:
                    return {'success': False, 'error': str(e)}
            
            worker = WorkerThread(load_remote_index)
            worker.result_ready.connect(lambda result: self._on_remote_unified_load_completed(result, progress_id, selected_index))
            worker.error_occurred.connect(lambda error: self._on_build_error(error, progress_id))
            worker.start()
            
            self.worker_threads.append(worker)
            
        except Exception as e:
            QMessageBox.critical(self, "Load Error", f"Failed to load remote unified index:\n{str(e)}")
    
    def _on_remote_unified_load_completed(self, result: Dict, progress_id: str, selected_index: Dict):
        """Handle remote unified index load completion"""
        try:
            if result['success']:
                stats = result['stats']
                
                self.progress_manager.update_progress(progress_id, 100, " Remote index loaded!")
                
                # Show success message similar to local unified index
                success_msg = (
                    f" Remote Unified Index Loaded Successfully!\n\n"
                    f" Connection Stats:\n"
                    f" Connection time: {stats['total_load_time']:.3f}s\n"
                    f" {stats.get('estimated_speedup', 'Network access enabled!')}\n"
                    f" Source: {stats['index_info'].get('source', 'Remote')}\n"
                    f" Type: {stats['index_info'].get('index_type', 'Remote Index')}\n\n"
                    f" You can now search across this remote index!"
                )
                
                self.show_info("Remote Index Loaded", success_msg)
                
                # Update system status like local index
                self._update_system_info()
                
                if self.logger:
                    # Mark system as ready for unified search (same as local index)
                    self.system._mark_unified_ready()
                    
                    # Update UI to show system is ready
                    self.search_input.setEnabled(True)
                    self.search_button.setEnabled(True)
                    
                    # Update chat interface to recognize new system with remote index
                    self._update_chat_interface_system()
                    
                    self.logger.info(f" Remote unified index loaded successfully: {selected_index['name']}")
                    self.logger.info(f" Remote index integrated with main system")
                    
            else:
                error_msg = result.get('error', 'Unknown error')
                self.show_error("Remote Load Error", f"Failed to load remote unified index:\n{error_msg}")
                
        except Exception as e:
            self.show_error("Load Error", f"Error processing remote index load: {str(e)}")
        finally:
            self.progress_manager.finish_progress(progress_id)
    
    def _update_chat_interface_system(self):
        """Update chat interface with current system for agent tools"""
        try:
            if hasattr(self, 'chat_widget') and self.chat_widget and self.system:
                # Update the retrieval system reference in the chat interface's LLM processor
                if hasattr(self.chat_widget, 'llm_processor') and self.chat_widget.llm_processor:
                    self.chat_widget.llm_processor.retrieval_system = self.system
                    
                    # Force re-initialization of agent tools
                    if hasattr(self.chat_widget.llm_processor, '_initialize_conversational_agent'):
                        try:
                            self.chat_widget.llm_processor._initialize_conversational_agent()
                            if self.logger:
                                self.logger.info(" Updated chat interface with remote index tools")
                        except Exception as e:
                            if self.logger:
                                self.logger.warning(f"Failed to reinitialize chat agent: {e}")
                
        except Exception as e:
            if self.logger:
                self.logger.warning(f"Failed to update chat interface system: {e}")
    
    def _on_unified_load_completed(self, result: Dict, progress_id: str):
        """Handle unified index load completion"""
        try:
            if result['success']:
                stats = result['stats']
                
                self.progress_manager.update_progress(progress_id, 100, " Unified index loaded!")
                
                # Show success message
                success_msg = (
                    f" Unified Index Loaded Successfully!\n\n"
                    f" Performance Stats:\n"
                    f" Load time: {stats['total_load_time']:.3f}s\n"
                    f" {stats.get('estimated_speedup', 'Much faster!')}\n"
                    f" Total frames: {stats['index_info'].get('processed_files', 0)}\n"
                    f" Memory-mapped: {stats['memory_mapped']}\n\n"
                    f" Ready for ultra-fast searching!"
                )
                
                QMessageBox.information(self, "Load Complete", success_msg)
                
                # Mark system as ready for unified search
                self.system._mark_unified_ready()
                
                # Update UI to show system is ready
                self.search_input.setEnabled(True)
                self.search_button.setEnabled(True)
                
                # Update chat interface to recognize unified index
                self._update_chat_interface_system()
                
            else:
                self.progress_manager.update_progress(progress_id, 0, " Load failed")
                QMessageBox.critical(self, "Load Failed", f"Failed to load unified index:\n\n{result['error']}")
                
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Error handling load result:\n{str(e)}")
        finally:
            self.progress_manager.finish_progress(progress_id)
    
    def _smart_load_system(self):
        """Smart load system: auto-detects legacy index, portable package, or unified index"""
        # Check if user wants to load a unified index file (.rvdb) or folder
        reply = QMessageBox.question(
            self,
            "Select Load Type",
            "What would you like to load?\n\n"
            " Unified Index: Single .rvdb file (10x faster)\n"
            " Legacy/Portable: Folder with multiple files",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )
        
        if reply == QMessageBox.Yes:
            # Load unified index file
            file_path, _ = QFileDialog.getOpenFileName(
                self, 
                "Select Unified Index File", 
                "", 
                "Unified Index Files (*.rvdb);;All Files (*)"
            )
            if file_path:
                self._load_unified_index(file_path)
        else:
            # Load legacy folder
            folder = QFileDialog.getExistingDirectory(self, "Select Index or Portable Package Folder")
            if not folder:
                return
            
            self._load_legacy_system(folder)
    
    def _load_legacy_system(self, folder: str):
        """Load legacy system from folder"""
        
        if not self.system:
            self._initialize_system()
        
        try:
           folder_path = Path(folder)
           is_portable = (folder_path / "manifest.json").exists()
           
           if is_portable:
               self._load_portable_package(folder)
           else:
               self._load_legacy_index(folder)
               
        except Exception as e:
           QMessageBox.critical(self, "Load Error", f"Failed to load system:\n{str(e)}")
   
    def _load_portable_package(self, package_dir):
       """Load portable package"""
       try:
           package_keyframes = os.path.join(package_dir, "keyframes")
           has_included_keyframes = os.path.exists(package_keyframes)
           
           keyframes_path = None
           
           if not has_included_keyframes:
               reply = QMessageBox.question(
                   self,
                   "Keyframes Location",
                   "This portable package doesn't include keyframes.\n\n"
                   "Specify keyframes location?\n"
                   "(Select 'No' to try auto-detection)",
                   QMessageBox.Yes | QMessageBox.No,
                   QMessageBox.No
               )
               
               if reply == QMessageBox.Yes:
                   keyframes_path = QFileDialog.getExistingDirectory(
                       self, 
                       "Select Keyframes Directory"
                   )
                   if not keyframes_path:
                       return
           
           progress_id = f"load_portable_{time.time()}"
           self.progress_manager.show_progress(progress_id, "Loading Portable Package", 100)
           
           success = self.system.load_portable_index(
               package_path=package_dir,
               keyframes_path=keyframes_path,
               auto_detect_keyframes=True
           )
           
           self.progress_manager.finish_progress(progress_id)
           
           if success:
               self._update_system_info()
               QMessageBox.information(
                   self, 
                   " Portable Package Loaded", 
                   f"Portable package loaded successfully!\n\n"
                   f" Package: {package_dir}\n"
                   f" System ready for searching."
               )
           else:
               QMessageBox.warning(self, "Warning", "Failed to load portable package.")
               
       except Exception as e:
           QMessageBox.critical(self, "Load Error", f"Failed to load portable package:\n{str(e)}")
   
    def _load_legacy_index(self, index_dir):
       """Load legacy index directory"""
       try:
           progress_id = f"load_legacy_{time.time()}"
           self.progress_manager.show_progress(progress_id, "Loading Legacy Index", 100)
           
           success = self.system.load_system(index_dir, validate_after_load=False)
           
           self.progress_manager.finish_progress(progress_id)
           
           if success:
               self._update_system_info()
               
               reply = QMessageBox.question(
                   self,
                   " Legacy Index Loaded",
                   f"Legacy index loaded successfully!\n\n"
                   f" Index: {index_dir}\n\n"
                   f" Tip: Create portable package for easier sharing?",
                   QMessageBox.Yes | QMessageBox.No,
                   QMessageBox.No
               )
               
               if reply == QMessageBox.Yes:
                   self._quick_export_portable()
           else:
               QMessageBox.warning(self, "Warning", "Failed to load legacy index.")
               
       except Exception as e:
           QMessageBox.critical(self, "Load Error", f"Failed to load legacy index:\n{str(e)}")
   
    def _quick_export_portable(self):
       """Quick export portable package"""
       try:
           export_dir = QFileDialog.getExistingDirectory(self, "Select Export Directory")
           if not export_dir:
               return
           
           import datetime
           timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
           package_name = f"portable_index_{timestamp}"
           package_path = os.path.join(export_dir, package_name)
           
           result = self.system.export_portable_index(
               output_path=package_path,
               include_keyframes=False
           )
           
           QMessageBox.information(
               self,
               "Export Successful",
               f" Portable package created!\n\n"
               f" Location: {result['package_path']}\n"
               f" Size: {result['size_mb']} MB\n"
               f" Ready to share with other machines"
           )
           
       except Exception as e:
           QMessageBox.critical(self, "Export Error", f"Failed to export:\n{str(e)}")
   
    def _on_smart_build_completed(self, success: bool):
       """Handle smart build completion with optional portable export"""
       build_info = getattr(self, '_build_info', {})
       progress_id = build_info.get('progress_id', f"build_{time.time()}")
       create_portable = build_info.get('create_portable', False)
       
       self.progress_manager.finish_progress(progress_id)
       
       if success:
           self._update_system_info()
           
           if create_portable:
               try:
                   import datetime
                   timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                   
                   keyframes_folder = build_info.get('keyframes_folder', '')
                   parent_dir = str(Path(keyframes_folder).parent) if keyframes_folder else str(Path.cwd())
                   package_name = f"portable_index_{timestamp}"
                   package_path = os.path.join(parent_dir, package_name)
                   
                   export_progress_id = f"export_{time.time()}"
                   self.progress_manager.show_progress(export_progress_id, "Creating Portable Package", 100)
                   
                   result = self.system.export_portable_index(
                       output_path=package_path,
                       include_keyframes=False
                   )
                   
                   self.progress_manager.finish_progress(export_progress_id)
                   
                   map_folder = build_info.get('map_folder', '')
                   map_info = f"\n Map folder: {map_folder}" if map_folder else ""
                   
                   QMessageBox.information(
                       self,
                       " Build & Export Complete",
                       f"System built and portable package created!\n\n"
                       f" Keyframes: {keyframes_folder}{map_info}\n"
                       f" Portable package: {result['package_path']}\n"
                       f" Package size: {result['size_mb']} MB\n\n"
                       f" Ready to copy package to other machines!"
                   )
                   
               except Exception as e:
                   QMessageBox.warning(
                       self,
                       "Export Warning", 
                       f"System built successfully but portable export failed:\n{str(e)}\n\n"
                       f"You can export manually later."
                   )
           else:
               map_folder = build_info.get('map_folder', '')
               map_info = f"\n Map folder: {map_folder}" if map_folder else ""
               
               QMessageBox.information(
                   self,
                   " Build Complete",
                   f"System built successfully!\n\n"
                   f" Keyframes: {build_info.get('keyframes_folder', 'Unknown')}{map_info}\n"
                   f" System ready for searching."
               )
       else:
           QMessageBox.critical(self, "Build Error", "Failed to build system.")
       
       self._build_info = {}
   
    def _on_build_completed(self, success: bool, progress_id: str):
       """Handle legacy build completion (fallback)"""
       self.progress_manager.finish_progress(progress_id)
       
       if success:
           self._update_system_info()
           QMessageBox.information(self, "Success", "System built successfully!")
       else:
           QMessageBox.warning(self, "Warning", "System build failed.")
   
    def _on_build_error(self, error: str, progress_id: str):
       """Handle system build error"""
       self.progress_manager.finish_progress(progress_id)
       QMessageBox.critical(self, "Build Error", f"System build failed:\n{error}")
   
    def _optimize_system(self):
       """Optimize system performance"""
       if not self.system:
           QMessageBox.warning(self, "Warning", "No system loaded.")
           return
       
       progress_id = f"optimize_{time.time()}"
       self.progress_manager.show_progress(progress_id, "Optimizing System", 100)
       
       try:
           worker = WorkerThread(self.system.optimize_index)
           worker.progress_updated.connect(lambda c, t, m: self.progress_manager.update_progress(progress_id, c if t <= 100 else int(c * 100 / t), m))
           worker.result_ready.connect(lambda result: self._on_optimize_completed(result, progress_id))
           worker.error_occurred.connect(lambda error: self._on_optimize_error(error, progress_id))
           worker.start()
           
           self.worker_threads.append(worker)
           self.status_bar.showMessage("Optimizing system...")
           
       except Exception as e:
           self.progress_manager.finish_progress(progress_id)
           QMessageBox.critical(self, "Error", f"Failed to start optimization:\n{str(e)}")
   
    def _on_optimize_completed(self, success: bool, progress_id: str):
       """Handle optimization completion"""
       self.progress_manager.finish_progress(progress_id)
       
       if success:
           self.status_bar.showMessage("System optimization completed")
           QMessageBox.information(self, "Success", "System optimized successfully!")
       else:
           self.status_bar.showMessage("System optimization had no effect")
           QMessageBox.warning(self, "Warning", "System optimization had no effect.")
   
    def _on_optimize_error(self, error: str, progress_id: str):
       """Handle optimization error"""
       self.progress_manager.finish_progress(progress_id)
       self.status_bar.showMessage("System optimization failed")
       QMessageBox.critical(self, "Error", f"Optimization failed:\n{error}")
   
    def _cleanup_system(self):
       """Cleanup system files"""
       if not self.system:
           QMessageBox.warning(self, "Warning", "No system loaded.")
           return
       
       reply = QMessageBox.question(
           self, "Confirm Cleanup", 
           "This will remove temporary files and clear cache. Continue?",
           QMessageBox.Yes | QMessageBox.No
       )
       
       if reply == QMessageBox.Yes:
           progress_id = f"cleanup_{time.time()}"
           self.progress_manager.show_progress(progress_id, "Cleaning System", 100)
           
           try:
               worker = WorkerThread(self.system.cleanup)
               worker.progress_updated.connect(lambda c, t, m: self.progress_manager.update_progress(progress_id, c if t <= 100 else int(c * 100 / t), m))
               worker.result_ready.connect(lambda result: self._on_cleanup_completed(result, progress_id))
               worker.error_occurred.connect(lambda error: self._on_cleanup_error(error, progress_id))
               worker.start()
               
               self.worker_threads.append(worker)
               self.status_bar.showMessage("Cleaning system...")
               
           except Exception as e:
               self.progress_manager.finish_progress(progress_id)
               QMessageBox.critical(self, "Error", f"Failed to start cleanup:\n{str(e)}")
   
    def _on_cleanup_completed(self, result, progress_id: str):
       """Handle cleanup completion"""
       self.progress_manager.finish_progress(progress_id)
       self.status_bar.showMessage("System cleanup completed")
       QMessageBox.information(self, "Success", "System cleanup completed!")
   
    def _on_cleanup_error(self, error: str, progress_id: str):
       """Handle cleanup error"""
       self.progress_manager.finish_progress(progress_id)
       self.status_bar.showMessage("System cleanup failed")
       QMessageBox.critical(self, "Error", f"Cleanup failed:\n{error}")
   
    def _update_system_info(self):
       """Update system information display"""
       if not self.system:
           self.system_status_label.setText("Not initialized")
           self.index_status_label.setText("No index loaded")
           self.performance_label.setText("No data")
           return
       
       try:
           if hasattr(self.system, 'status') and self.system.status:
               status = self.system.status
               self.system_status_label.setText("Ready" if status.is_ready else "Not Ready")
               self.index_status_label.setText("Loaded" if status.index_loaded else "Not Loaded")
           else:
               has_index = hasattr(self.system, 'index') and self.system.index is not None
               self.system_status_label.setText("Ready" if has_index else "Not Ready")
               self.index_status_label.setText("Loaded" if has_index else "Not Loaded")
           
           self._refresh_stats()
           
       except Exception as e:
           self.system_status_label.setText(f"Error: {str(e)}")
   
    def _refresh_stats(self):
       """Refresh system statistics"""
       if not self.system:
           return
       
       try:
           stats = []
           
           if hasattr(self.system, 'index') and self.system.index:
               stats.append(("Index Status", "Loaded"))
               stats.append(("Total Images", str(getattr(self.system.index, 'ntotal', 'Unknown'))))
           else:
               stats.append(("Index Status", "Not Loaded"))
           
           if hasattr(self.system, 'config'):
               stats.append(("Config Status", "Loaded"))
           
           # Add remote indexes info
           if hasattr(self.system, 'remote_indexes') and self.system.remote_indexes:
               stats.append(("Remote Indexes", str(len(self.system.remote_indexes))))
               for i, remote_idx in enumerate(self.system.remote_indexes):
                   stats.append((f"Remote {i+1}", f"{remote_idx['name']} ({remote_idx['host']})"))
           
           self.stats_table.setRowCount(len(stats))
           for i, (key, value) in enumerate(stats):
               self.stats_table.setItem(i, 0, QTableWidgetItem(key))
               self.stats_table.setItem(i, 1, QTableWidgetItem(value))
           
       except Exception as e:
           pass
   
    def _refresh_all(self):
       """Refresh all information"""
       self._update_system_info()
       self.status_bar.showMessage("Information refreshed")
   
    def _show_about(self):
       """Show about dialog"""
       about_text = """
       <h2>Enhanced Retrieval System v2.1</h2>
       <p>Advanced AI-powered image retrieval system with:</p>
       <ul>
       <li>CLIP-based similarity search</li>
       <li>OpenAI-enhanced query processing</li>
       <li>FAISS high-speed indexing</li>
       <li>Multi-modal search capabilities</li>
       <li>Real-time chat interface</li>
       <li>Video frame filtering</li>
       <li>Split-view result display</li>
       </ul>
       <p><b>Developed by:</b> Enhanced Retrieval System Team</p>
       <p><b>Version:</b> 2.1 (Refactored - OpenAI Only)</p>
       """
       
       QMessageBox.about(self, "About Enhanced Retrieval System", about_text)
    
    def eventFilter(self, obj, event):
        """Event filter to handle Enter key in search input"""
        if obj == self.search_input:
            if event.type() == QEvent.KeyPress:
                if event.key() == Qt.Key_Return or event.key() == Qt.Key_Enter:
                    # Check if Shift is pressed (for new line)
                    if event.modifiers() & Qt.ShiftModifier:
                        # Let the default behavior handle Shift+Enter (new line)
                        return False
                    else:
                        # Enter without Shift = trigger search
                        self._on_search_clicked()
                        return True  # Event handled
        
        # Let the default event handler process other events
        return super().eventFilter(obj, event)
    
    def show_error(self, title: str, message: str):
        """Show error dialog"""
        QMessageBox.critical(self, title, message)
    
    def show_warning(self, title: str, message: str):
        """Show warning dialog"""
        QMessageBox.warning(self, title, message)
    
    def show_info(self, title: str, message: str):
        """Show information dialog"""
        QMessageBox.information(self, title, message)
   
    def _set_window_icon(self):
        """Set window icon from logo file or fallback"""
        try:
            # Try to load logo.png from various locations
            logo_paths = [
                'logo.png',                    # Current directory
                os.path.join(os.path.dirname(__file__), 'logo.png'),  # Script directory
                './logo.png',                  # Relative path
                os.path.join(sys._MEIPASS, 'logo.png') if getattr(sys, '_MEIPASS', None) else None,  # PyInstaller bundle
            ]
            
            # Filter out None paths
            logo_paths = [path for path in logo_paths if path is not None]
            
            icon_set = False
            for logo_path in logo_paths:
                if os.path.exists(logo_path):
                    try:
                        pixmap = QPixmap(logo_path)
                        if not pixmap.isNull():
                            # Create icon with multiple sizes
                            icon = QIcon()
                            for size in [16, 24, 32, 48, 64, 128, 256]:
                                scaled_pixmap = pixmap.scaled(size, size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                                icon.addPixmap(scaled_pixmap)
                            
                            self.setWindowIcon(icon)
                            
                            # Also set application icon
                            app = QApplication.instance()
                            if app:
                                app.setWindowIcon(icon)
                            
                            if self.logger:
                                self.logger.info(f"Logo loaded successfully from: {logo_path}")
                            icon_set = True
                            break
                    except Exception as e:
                        if self.logger:
                            self.logger.warning(f"Failed to load logo from {logo_path}: {e}")
                        continue
            
            if not icon_set:
                # Fallback to base64 icon if logo not found
                try:
                    icon_data = QByteArray.fromBase64(image_base64.split(',')[1].encode())
                    icon_pixmap = QPixmap()
                    icon_pixmap.loadFromData(icon_data)
                    if not icon_pixmap.isNull():
                        self.setWindowIcon(QIcon(icon_pixmap))
                        if self.logger:
                            self.logger.info("Using fallback base64 icon")
                except Exception as e:
                    if self.logger:
                        self.logger.warning(f"Failed to load fallback icon: {e}")
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"Icon loading failed: {e}")

    def closeEvent(self, event):
       """Handle application close"""
       # Clean up chat interface threads first
       if hasattr(self, 'chat_widget') and hasattr(self.chat_widget, 'cleanup_all_threads'):
           self.chat_widget.cleanup_all_threads()
       
       # Cancel all worker threads from main window
       active_threads = []
       for worker in self.worker_threads[:]:
           if worker.isRunning():
               worker.cancel()
               active_threads.append(worker)
       
       # Wait for main window threads to finish
       for worker in active_threads:
           if not worker.wait(3000):
               worker.terminate()
               worker.wait(1000)
       
       self.worker_threads.clear()
       
       event.accept()

# ================================================================================
# MODULE-LEVEL CONVENIENCE FUNCTIONS
# ================================================================================

def create_main_window(retrieval_system: Optional[EnhancedRetrievalSystem] = None) -> MainWindow:
   """Create main window instance"""
   return MainWindow(retrieval_system)

def run_application(retrieval_system: Optional[EnhancedRetrievalSystem] = None) -> int:
   """Run the GUI application"""
   if not HAS_PYQT5:
       print("PyQt5 not found. Please install PyQt5:")
       print("pip install PyQt5")
       return 1
   
   app = QApplication(sys.argv if not QApplication.instance() else [])
   app.setApplicationName("Enhanced Retrieval System")
   app.setApplicationVersion("2.1")
   app.setOrganizationName("Enhanced Retrieval System")
   
   window = MainWindow(retrieval_system)
   window.setWindowFlags(Qt.Window | Qt.WindowStaysOnTopHint)
   window.show()
   
   def reset_window_flags():
       window.setWindowFlags(Qt.Window)
       window.show()
       window.activateWindow()
       window.raise_()
   
   QTimer.singleShot(1000, reset_window_flags)
   
   return app.exec_()


if __name__ == "__main__":
   # Standalone GUI application
   try:
       sys.stdout.reconfigure(encoding='utf-8')
   except UnicodeEncodeError:
       pass
   print("=" * 50)
   
   if not HAS_PYQT5:
       print("PyQt5 not found. Please install PyQt5:")
       print("pip install PyQt5")
       sys.exit(1)
   
   try:
       exit_code = run_application()
       sys.exit(exit_code)
       
   except Exception as e:
       print(f"Application error: {str(e)}")
       traceback.print_exc()
       sys.exit(1)